
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<title>SH</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="/global/main.css" title="default">
</head>

<body>



<div id="container">


<div id="content">

<div id='catHeader'><table width='100%'><tr><td>
<H1>SH</H1>
Section: User Commands  (1)<BR>
</td><td align='right' valign='bottom'><div class='ad_header_right'></div></td></tr></table></div></div>
<div id='categories'>
<div class='ad_man_right'>
</div>
<BR>BSD mandoc<BR>


<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

sh - command interpreter (shell)
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<B>sh</B>

[-<B>/+aCefnuvxIimqsVEbc</B>

]

[-<B>o </B><I>longname</I>



]

-words

[<I>target ...</I>

]

<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>



Sh is the standard command interpreter for the system. The current version
of
<B>sh</B>


is in the process of being changed to conform with the
<B>POSIX</B>

1003.2 and 1003.2a specifications for the shell.  This version has many
features which make it appear similar in some respects to the Korn shell,
but it is not a Korn shell clone (see
<A HREF="../man1/ksh.1.php">ksh</A>(1)).


Only features designated by
<B>POSIX</B>

 
plus a few Berkeley extensions, are being incorporated into this shell.
We expect
<B>POSIX</B>

conformance by the time 4.4 BSD is released. This man page is not intended
to be a tutorial or a complete specification of the shell.
<A NAME="lbAE">&nbsp;</A>
<H3>Overview</H3>

The shell is a command that reads lines from either a file or the
terminal, interprets them, and generally executes other commands. It is
the program that is running when a user logs into the system (although a
user can select a different shell with the
<A HREF="../man1/chsh.1.php">chsh</A>(1)


command). The shell implements a language that has flow control
constructs, a macro facility that provides a variety of features in
addition to data storage.  It incorporates many features to aid interactive
use and has the advantage that the interpretative language is common to both
interactive and non-interactive use (shell scripts).  That is, commands
can be typed directly to the running shell or can be put into a file and
the file can be executed directly by the shell.
<A NAME="lbAF">&nbsp;</A>
<H3>Invocation</H3>

If no args are present and if the standard input of the shell
is connected to a terminal (or if the
-<B>i</B>

flag is set),
and the 
-<B>c</B>

option is not present, the shell is considered an interactive shell.  An
interactive shell generally prompts before each command and handles
programming and command errors differently (as described below). When
first starting, the shell inspects argument 0, and if it begins with a
dash
`-'

 
the shell is also considered
a login shell.  This is normally done automatically by the system
when the user first logs in. A login shell first reads commands
from the files
/etc/profile

and
.profile

if they exist.
If the environment variable
<B>ENV</B>

is set on entry to a shell, or is set in the
.profile

of a login shell, the shell next reads
commands from the file named in
<B>ENV</B>

 
Therefore, a user should place commands that are to be executed only at
login time in the
.profile

file, and commands that are executed for every shell inside the
<B>ENV</B>

file.  To set the
<B>ENV</B>

variable to some file, place the following line in your
.profile

of your home directory
<P>


<BLOCKQUOTE><TT>ENV=$HOME/.shinit; export ENV</TT></BLOCKQUOTE>
<P>

substituting for
``.shinit''

any filename you wish. Since the
<B>ENV</B>

file is read for every invocation of the shell, including shell scripts
and non-interactive shells, the following paradigm is useful for
restricting commands in the
<B>ENV</B>

file to interactive invocations. Place commands within the
``case''

and
``esac''

below (these commands are described later):
<P>

<DL COMPACT>
<P>

<DT><B>case $- in *i*)</B>


<DD>
<DL COMPACT>
<P>

<DT><B># commands for interactive use only</B>


<DD>
<DT><B>...</B>


<DD>
</DL>
<P>

<DT><B>esac</B>


<DD>
</DL>
<P>

<P>

If command line arguments besides the options have been specified, then
the shell treats the first argument as the name of a file from which to
read commands (a shell script), and the remaining arguments are set as the
positional parameters of the shell ($1, $2, etc).  Otherwise, the shell
reads commands from its standard input.
<A NAME="lbAG">&nbsp;</A>
<H3>Argument List Processing</H3>

All of the single letter options have a corresponding name that can be
used as an argument to the
-<B>o</B>

option. The set
-<B>o</B>

name is provided next to the single letter option in
the description below. Specifying a dash
``-''

turns the option on, while using a plus
``+''

disables the option.
The following options can be set from the command line or
with the
<A HREF="../man1/set.1.php">set</A>(1)


builtin (described later).
<DL COMPACT>
<P>

<DT><B>-a </B><I>allexport</I>




<DD>
Export all variables assigned to. (UNIMPLEMENTED for 4.4alpha)
<DT><B>-c</B>


<DD>
Read commands from the command line.
No commands will be read from the standard input.
<DT><B>-C </B><I>noclobber</I>




<DD>
Don't overwrite existing files with
``&gt;''

 
(UNIMPLEMENTED for 4.4alpha)
<DT><B>-e </B><I>errexit</I>




<DD>
If not interactive, exit immediately if any untested command fails.
The exit status of a command is considered to be
explicitly tested if the command is used to control
an
<B>if</B>

 
<B>elif</B>

 
<B>while</B>

 
or
<B>until</B>

 
or if the command is the left hand operand of an
``&amp;&amp;''

or
``||''

operator.
<DT><B>-f </B><I>noglob</I>




<DD>
Disable pathname expansion.
<DT><B>-n </B><I>noexec</I>




<DD>
If not interactive, read commands but do not execute them.  This is useful
for checking the syntax of shell scripts.
<DT><B>-u </B><I>nounset</I>




<DD>
Write a message to standard error when attempting to expand a variable
that is not set, and if the shell is not interactive, exit immediately.
(UNIMPLEMENTED for 4.4alpha)
<DT><B>-v </B><I>verbose</I>




<DD>
The shell writes its input to standard error as it is read.  Useful for
debugging.
<DT><B>-x </B><I>xtrace</I>




<DD>
Write each command to standard error (preceded
by a
`+&nbsp;'

 
before it is executed.  Useful for debugging.
<DT><B>-q </B><I>quietprofile</I>




<DD>
If the
-<B>v</B>

or
-<B>x</B>

options have been set, do not apply them when reading
initialization files, these being
/etc/profile

 
.profile

 
and the file specified by the
<B>ENV</B>

environment variable.
<DT><B>-I </B><I>ignoreeof</I>




<DD>
Ignore EOF's from input when interactive.
<DT><B>-i </B><I>interactive</I>




<DD>
Force the shell to behave interactively.
<DT><B>-m </B><I>monitor</I>




<DD>
Turn on job control (set automatically when interactive).
<DT><B>-s </B><I>stdin</I>




<DD>
Read commands from standard input (set automatically if no file arguments
are present).  This option has no effect when set after the shell has
already started running (i.e. with
<A HREF="../man1/set.1.php">set</A>(1)).


<DT><B>-V </B><I>vi</I>




<DD>
Enable the built-in
<A HREF="../man1/vi.1.php">vi</A>(1)


command line editor (disables
-<B>E</B>

if it has been set).
<DT><B>-E </B><I>emacs</I>




<DD>
Enable the built-in
<A HREF="../man1/emacs.1.php">emacs</A>(1)


command line editor (disables
-<B>V</B>

if it has been set).
<DT><B>-b </B><I>notify</I>




<DD>
Enable asynchronous notification of background job completion.
(UNIMPLEMENTED for 4.4alpha)
</DL>
<P>

<A NAME="lbAH">&nbsp;</A>
<H3>Lexical Structure</H3>

The shell reads input in terms of lines from a file and breaks it up into
words at whitespace (blanks and tabs), and at certain sequences of
characters that are special to the shell called
``operators''

 
There are two types of operators: control operators and redirection
operators (their meaning is discussed later). Following is a list of operators:
<DL COMPACT>
<P>

<DT><B>&quot;Control operators:&quot;</B>
<DD>

<BLOCKQUOTE><TT>&amp;  &amp;&amp;  (  )  ;  ;; | || &lt;newline&gt;</TT></BLOCKQUOTE>
<DT><B>&quot;Redirection operator:&quot;</B>
<DD>

<BLOCKQUOTE><TT>&lt;  &gt;  &gt;|  &lt;&lt;  &gt;&gt;  &lt;&amp;  &gt;&amp;  &lt;&lt;-  &lt;&gt;</TT></BLOCKQUOTE>
</DL>
<P>

<A NAME="lbAI">&nbsp;</A>
<H3>Quoting</H3>

Quoting is used to remove the special meaning of certain characters or
words to the shell, such as operators, whitespace, or keywords.  There are
three types of quoting: matched single quotes, matched double quotes, and
backslash.
<A NAME="lbAJ">&nbsp;</A>
<H3>Backslash</H3>

A backslash preserves the literal meaning of the following
character, with the exception of
Aq newline .

A backslash preceding a
Aq newline

is treated as a line continuation.
<A NAME="lbAK">&nbsp;</A>
<H3>Single Quotes</H3>

Enclosing characters in single quotes preserves the literal meaning of all
the characters (except single quotes, making it impossible to put
single-quotes in a single-quoted string).
<A NAME="lbAL">&nbsp;</A>
<H3>Double Quotes</H3>

Enclosing characters within double quotes preserves the literal
meaning of all characters except dollarsign
($)

 
backquote
(`)

 
and backslash
(\)

 
The backslash inside double quotes is historically weird, and serves to
quote only the following characters:

<BLOCKQUOTE><TT>$  `    \  &lt;newline&gt;</TT></BLOCKQUOTE>
 
Otherwise it remains literal.
<A NAME="lbAM">&nbsp;</A>
<H3>Reserved Words</H3>

Reserved words are words that have special meaning to the
shell and are recognized at the beginning of a line and
after a control operator.  The following are reserved words:
<DL COMPACT>
<P>

<DT><B>! Ta </B>elif Ta fi Ta while Ta case








<DD>
<DT><B>else Ta </B>for Ta then Ta { Ta }








<DD>
<DT><B>do Ta </B>done Ta until Ta if Ta esac








<DD>
</DL>
<P>

<P>

Their meaning is discussed later.
<A NAME="lbAN">&nbsp;</A>
<H3>Aliases</H3>

An alias is a name and corresponding value set using the
<A HREF="../man1/alias.1.php">alias</A>(1)


builtin command.  Whenever a reserved word may occur (see above),
and after checking for reserved words, the shell
checks the word to see if it matches an alias. If it does,
it replaces it in the input stream with its value.  For example,
if there is an alias called
``lf''

with the value
``ls -F''

 
then the input:
<P>


<BLOCKQUOTE><TT>lf foobar &lt;return&gt;</TT></BLOCKQUOTE>
<P>

would become
<P>


<BLOCKQUOTE><TT>ls -F foobar &lt;return&gt;</TT></BLOCKQUOTE>
<P>

Aliases provide a convenient way for naive users to create shorthands for
commands without having to learn how to create functions with arguments.
They can also be used to create lexically obscure code.  This use is
discouraged.
<A NAME="lbAO">&nbsp;</A>
<H3>Commands</H3>

The shell interprets the words it reads according to a language, the
specification of which is outside the scope of this man page (refer to the
BNF in the
<B>POSIX</B>

1003.2 document).  Essentially though, a line is read and if the first
word of the line (or after a control operator) is not a reserved word,
then the shell has recognized a simple command.  Otherwise, a complex
command or some other special construct may have been recognized.
<A NAME="lbAP">&nbsp;</A>
<H3>Simple Commands</H3>

If a simple command has been recognized, the shell performs
the following actions:
<OL><P>

<LI>

Leading words of the form
``name=value''

are stripped off and assigned to the environment of the simple command.
Redirection operators and their arguments (as described below) are
stripped off and saved for processing.
<LI>

The remaining words are expanded as described in
the section called
``Expansions''

 
and the first remaining word is considered the command name and the
command is located.  The remaining words are considered the arguments of
the command. If no command name resulted, then the
``name=value''

variable assignments recognized in item 1 affect the current shell.
<LI>

Redirections are performed as described in the next section.
</OL><P>

<A NAME="lbAQ">&nbsp;</A>
<H3>Redirections</H3>

Redirections are used to change where a command reads its input or sends
its output.  In general, redirections open, close, or duplicate an
existing reference to a file.  The overall format used for redirection is:
<P>


<BLOCKQUOTE><TT>[n] </TT><I>redir-op file</I>



</BLOCKQUOTE>
<P>

where
<I>redir-op</I>

is one of the redirection operators mentioned previously.  Following is a
list of the possible redirections. The
Bq n

is an optional number, as in
`3'

(not
`Bq 3

'

 
that refers to a file descriptor.
<DL COMPACT>
<P>

<DT><B>[n] &gt; file</B>


<DD>
Redirect standard output (or n) to file.
<DT><B>[n] &gt;| file</B>


<DD>
Same, but override the
-<B>C</B>

option.
<DT><B>[n] &gt;&gt; file</B>


<DD>
Append standard output (or n) to file.
<DT><B>[n] &lt; file</B>


<DD>
Redirect standard input (or n) from file.
<DT><B>[n1] &lt;&amp; n2</B>




<DD>
Duplicate standard input (or n1) from file descriptor n2.
<DT><B>[n] &lt;&amp;-</B>


<DD>
Close standard input (or n).
<DT><B>[n1] &gt;&amp; n2</B>




<DD>
Duplicate standard output (or n1) from n2.
<DT><B>[n] &gt;&amp;-</B>


<DD>
Close standard output (or n).
<DT><B>[n] &lt;&gt; file</B>


<DD>
Open file for reading and writing on standard input (or n).
</DL>
<P>

<P>

The following redirection is often called a
``here-document''

 
<DL COMPACT>
<P>

<DT><B>[n]&lt;&lt; delimiter</B>


<DD>

<BLOCKQUOTE><TT>here-doc-text...</TT></BLOCKQUOTE>
<B>delimiter</B>

</DL>
<P>

<P>

All the text on successive lines up to the delimiter is saved away and
made available to the command on standard input, or file descriptor n if
it is specified.  If the delimiter as specified on the initial line is
quoted, then the here-doc-text is treated literally, otherwise the text is
subjected to parameter expansion, command substitution, and arithmetic
expansion (as described in the section on
``Expansions )''

 
If the operator is
``&lt;&lt;-''

instead of
``&lt;&lt;''

 
then leading tabs in the here-doc-text are stripped.
<A NAME="lbAR">&nbsp;</A>
<H3>Search and Execution</H3>

There are three types of commands: shell functions, builtin commands, and
normal programs -- and the command is searched for (by name) in that
order.  They each are executed in a different way.
<P>

When a shell function is executed, all of the shell positional parameters
(except $0, which remains unchanged) are set to the arguments of the shell
function. The variables which are explicitly placed in the environment of
the command (by placing assignments to them before the function name) are
made local to the function and are set to the values given. Then the
command given in the function definition is executed.  The positional
parameters are restored to their original values when the command
completes. This all occurs within the current shell.
<P>

Shell builtins are executed internally to the shell, without spawning a
new process.
<P>

Otherwise, if the command name doesn't match a function or builtin, the
command is searched for as a normal program in the filesystem (as
described in the next section). When a normal program is executed, the
shell runs the program, passing the arguments and the environment to the
program. If the program is not a normal executable file (i.e., if it does
not begin with the &quot;magic number&quot; whose
<B>ASCII</B>

representation is &quot;#!&quot;, so
<A HREF="../man2/execve.2.php">execve</A>(2)


returns
Er ENOEXEC

then) the shell will interpret the program in a subshell.  The child shell
will reinitialize itself in this case, so that the effect will be as if a
new shell had been invoked to handle the ad-hoc shell script, except that
the location of hashed commands located in the parent shell will be
remembered by the child.
<P>

Note that previous versions of this document and the source code itself
misleadingly and sporadically refer to a shell script without a magic
number as a &quot;shell procedure&quot;.
<A NAME="lbAS">&nbsp;</A>
<H3>Path Search</H3>

<P>

When locating a command, the shell first looks to see if it has a shell
function by that name.  Then it looks for a builtin command by that name.
If a builtin command is not found, one of two things happen:
<OL><P>

<LI>

Command names containing a slash are simply executed without performing
any searches.
<LI>

The shell searches each entry in
<B>PATH</B>

in turn for the command. The value of the
<B>PATH</B>

variable should be a series of entries separated by colons.  Each entry
consists of a directory name. The current directory may be indicated
implicitly by an empty directory name, or explicitly by a single period.
</OL><P>

<A NAME="lbAT">&nbsp;</A>
<H3>Command Exit Status</H3>

Each command has an exit status that can influence the behavior
of other shell commands.  The paradigm is that a command exits
with zero for normal or success, and non-zero for failure,
error, or a false indication.  The man page for each command
should indicate the various exit codes and what they mean.
Additionally, the builtin commands return exit codes, as does
an executed shell function.
<A NAME="lbAU">&nbsp;</A>
<H3>Complex Commands</H3>

Complex commands are combinations of simple commands with control
operators or reserved words, together creating a larger complex command.
More generally, a command is one of the following:
<UL><P>

<LI>

simple command
<LI>

pipeline
<LI>

list or compound-list
<LI>

compound command
<LI>

function definition
</UL><P>

<P>

Unless otherwise stated, the exit status of a command is that of the last
simple command executed by the command.
<A NAME="lbAV">&nbsp;</A>
<H3>Pipelines</H3>

<P>

A pipeline is a sequence of one or more commands separated
by the control operator |.  The standard output of all but
the last command is connected to the standard input
of the next command.  The standard output of the last
command is inherited from the shell, as usual.
<P>

The format for a pipeline is:
<P>


<BLOCKQUOTE><TT>[!] command1 [ | command2 ...]</TT></BLOCKQUOTE>
<P>

The standard output of command1 is connected to the standard input of
command2. The standard input, standard output, or both of a command is
considered to be assigned by the pipeline before any redirection specified
by redirection operators that are part of the command.
<P>

If the pipeline is not in the background (discussed later), the shell
waits for all commands to complete.
<P>

If the reserved word ! does not precede the pipeline, the exit status is
the exit status of the last command specified in the pipeline.
Otherwise, the exit status is the logical NOT of the exit status of the
last command.  That is, if the last command returns zero, the exit status
is 1; if the last command returns greater than zero, the exit status is
zero.
<P>

Because pipeline assignment of standard input or standard output or both
takes place before redirection, it can be modified by redirection.  For
example:
<P>


<BLOCKQUOTE><TT>$ command1 2&gt;&amp;1 | command2</TT></BLOCKQUOTE>
<P>

sends both the standard output and standard error of command1
to the standard input of command2.
<P>

A ; or &lt;newline&gt; terminator causes the preceding AND-OR-list (described
next) to be executed sequentially; a &amp; causes asynchronous execution of
the preceding AND-OR-list.
<P>

Note that unlike some other shells, each process in the pipeline is a
child of the invoking shell (unless it is a shell builtin, in which case
it executes in the current shell -- but any effect it has on the
environment is wiped).
<A NAME="lbAW">&nbsp;</A>
<H3>Background Commands --</H3>

 
If a command is terminated by the control operator ampersand (&amp;), the
shell executes the command asynchronously -- that is, the shell does not
wait for the command to finish before executing the next command.
<P>

The format for running a command in background is:
<P>


<BLOCKQUOTE><TT>command1 &amp; [command2 &amp; ...]</TT></BLOCKQUOTE>
<P>

If the shell is not interactive, the standard input of an asynchronous
command is set to
/dev/null

 
<A NAME="lbAX">&nbsp;</A>
<H3>Lists -- Generally Speaking</H3>

A list is a sequence of zero or more commands separated by newlines,
semicolons, or ampersands, and optionally terminated by one of these three
characters. The commands in a list are executed in the order they are
written. If command is followed by an ampersand, the shell starts the
command and immediately proceed onto the next command; otherwise it waits
for the command to terminate before proceeding to the next one.
<A NAME="lbAY">&nbsp;</A>
<H3>Short-Circuit List Operators</H3>

``&amp;&amp;''

and
``||''

are AND-OR list operators.
``&amp;&amp;''

executes the first command, and then executes the second command iff the
exit status of the first command is zero.
``||''

is similar, but executes the second command iff the exit status of the first
command is nonzero.
``&amp;&amp;''

and
``||''

both have the same priority.
<A NAME="lbAZ">&nbsp;</A>
<H3>Flow-Control Constructs -- if, while, for, case</H3>

The syntax of the if command is

<BLOCKQUOTE>
<PRE>
if list
then list
[ elif list
then    list ] ...
[ else list ]
fi
</PRE>
</BLOCKQUOTE>

<P>

The syntax of the while command is

<BLOCKQUOTE>
<PRE>
while list
do   list
done
</PRE>
</BLOCKQUOTE>

<P>

The two lists are executed repeatedly while the exit status of the
first list is zero.  The until command is similar, but has the word
until in place of while, which causes it to
repeat until the exit status of the first list is zero.
<P>

The syntax of the for command is

<BLOCKQUOTE>
<PRE>
for variable in word...
do   list
done
</PRE>
</BLOCKQUOTE>

<P>

The words are expanded, and then the list is executed repeatedly with the
variable set to each word in turn.  do and done may be replaced with
``{''

and
``}''

 
<P>

The syntax of the break and continue command is

<BLOCKQUOTE>
<PRE>
break [ num ]
continue [ num ]
</PRE>
</BLOCKQUOTE>

<P>

Break terminates the num innermost for or while loops.
Continue continues with the next iteration of the innermost loop.
These are implemented as builtin commands.
<P>

The syntax of the case command is

<BLOCKQUOTE>
<PRE>
case word in
pattern) list ;;
...
esac
</PRE>
</BLOCKQUOTE>

<P>

The pattern can actually be one or more patterns (see Shell
Patterns described later), separated by
``''

characters.
<A NAME="lbBA">&nbsp;</A>
<H3>Grouping Commands Together</H3>

Commands may be grouped by writing either
<P>


<BLOCKQUOTE><TT>(list)</TT></BLOCKQUOTE>
<P>

or
<P>


<BLOCKQUOTE><TT>{ list;</TT></BLOCKQUOTE>
 
<P>

The first of these executes the commands in a subshell. Builtin commands
grouped into a (list) will not affect the current shell. The second form
does not fork another shell so is slightly more efficient. Grouping
commands together this way allows you to redirect their output as though
they were one program:
<P>


<BLOCKQUOTE>
<PRE>
{ printf  hello  ; printf  world\n&quot; ; } &gt; greeting
</PRE>
</BLOCKQUOTE>

<P>

<A NAME="lbBB">&nbsp;</A>
<H3>Functions</H3>

The syntax of a function definition is
<P>


<BLOCKQUOTE><TT>name ( ) command</TT></BLOCKQUOTE>
<P>

A function definition is an executable statement; when executed it
installs a function named name and returns an exit status of zero.  The
command is normally a list enclosed between
``{''

and
``}''

 
<P>

Variables may be declared to be local to a function by using a local
command.  This should appear as the first statement of a function, and the
syntax is
<P>


<BLOCKQUOTE><TT>local [ variable | - ] ...</TT></BLOCKQUOTE>
<P>

Local is implemented as a builtin command.
<P>

When a variable is made local, it inherits the initial value and exported
and readonly flags from the variable with the same name in the surrounding
scope, if there is one.  Otherwise, the variable is initially unset.  The
shell uses dynamic scoping, so that if you make the variable x local to
function f, which then calls function g, references to the variable x made
inside g will refer to the variable x declared inside f, not to the global
variable named x.
<P>

The only special parameter than can be made local is
``-''

 
Making
``-''

local any shell options that are changed via the set command inside the
function to be restored to their original values when the function
returns.
<P>

The syntax of the return command is
<P>


<BLOCKQUOTE><TT>return [ exitstatus</TT></BLOCKQUOTE>
 
<P>

It terminates the currently executing function.  Return is
implemented as a builtin command.
<A NAME="lbBC">&nbsp;</A>
<H3>Variables and Parameters</H3>

The shell maintains a set of parameters.  A parameter denoted by a name is
called a variable. When starting up, the shell turns all the environment
variables into shell variables.  New variables can be set using the form
<P>


<BLOCKQUOTE><TT>name=value</TT></BLOCKQUOTE>
<P>

Variables set by the user must have a name consisting solely of
alphabetics, numerics, and underscores - the first of which must not be
numeric.  A parameter can also be denoted by a number or a special
character as explained below.
<A NAME="lbBD">&nbsp;</A>
<H3>Positional Parameters</H3>

A positional parameter is a parameter denoted by a number (n &gt; 0). The
shell sets these initially to the values of its command line arguments
that follow the name of the shell script. The
<A HREF="../man1/set.1.php">set</A>(1)


builtin can also be used to set or reset them.
<A NAME="lbBE">&nbsp;</A>
<H3>Special Parameters</H3>

A special parameter is a parameter denoted by one of the following special
characters.  The value of the parameter is listed next to its character.
<DL COMPACT>
<P>

<DT><B>*</B>
<DD>
Expands to the positional parameters, starting from one.  When the
expansion occurs within a double-quoted string it expands to a single
field with the value of each parameter separated by the first character of
the
<B>IFS</B>

variable, or by a &lt;space&gt; if
<B>IFS</B>

is unset.
<DT><B>@</B>
<DD>
Expands to the positional parameters, starting from one.  When
the expansion occurs within double-quotes, each positional
parameter expands as a separate argument.
If there are no positional parameters, the
expansion of @ generates zero arguments, even when @ is
double-quoted.  What this basically means, for example, is
if $1 is
``abc''

and $2 is
``def ghi''

 
then
Qq $@

expands to
the two arguments:
<P>



<BLOCKQUOTE><TT> abc  &nbsp;  def&nbsp;ghi </TT></BLOCKQUOTE>

<DT><B>#</B>
<DD>
Expands to the number of positional parameters.
<DT><B>?</B>
<DD>
Expands to the exit status of the most recent pipeline.
<DT><B>- (Hyphen.)</B>
<DD>
Expands to the current option flags (the single-letter
option names concatenated into a string) as specified on
invocation, by the set builtin command, or implicitly
by the shell.
<DT><B>$</B>
<DD>
Expands to the process ID of the invoked shell.  A subshell
retains the same value of $ as its parent.
<DT><B>!</B>
<DD>
Expands to the process ID of the most recent background
command executed from the current shell.  For a
pipeline, the process ID is that of the last command in the
pipeline.
<DT><B>0 (Zero.)</B>
<DD>
Expands to the name of the shell or shell script.
</DL>
<P>

<A NAME="lbBF">&nbsp;</A>
<H3>Word Expansions</H3>

This clause describes the various expansions that are performed on words.
Not all expansions are performed on every word, as explained later.
<P>

Tilde expansions, parameter expansions, command substitutions, arithmetic
expansions, and quote removals that occur within a single word expand to a
single field.  It is only field splitting or pathname expansion that can
create multiple fields from a single word. The single exception to this
rule is the expansion of the special parameter @ within double-quotes, as
was described above.
<P>

The order of word expansion is:
<OL><P>

<LI>

Tilde Expansion, Parameter Expansion, Command Substitution,
Arithmetic Expansion (these all occur at the same time).
<LI>

Field Splitting is performed on fields
generated by step (1) unless the
<B>IFS</B>

variable is null.
<LI>

Pathname Expansion (unless set
-<B>f</B>

is in effect).
<LI>

Quote Removal.
</OL><P>

<P>

The $ character is used to introduce parameter expansion, command
substitution, or arithmetic evaluation.
<A NAME="lbBG">&nbsp;</A>
<H3>Tilde Expansion (substituting a user's home directory)</H3>

A word beginning with an unquoted tilde character (~) is
subjected to tilde expansion.  All the characters up to
a slash (/) or the end of the word are treated as a username
and are replaced with the user's home directory.  If the
username is missing (as in
~/foobar )

 
the tilde is replaced with the value of the
<I>HOME</I>

variable (the current user's home directory).
<A NAME="lbBH">&nbsp;</A>
<H3>Parameter Expansion</H3>

The format for parameter expansion is as follows:
<P>


<BLOCKQUOTE><TT>${expression}</TT></BLOCKQUOTE>
<P>

where expression consists of all characters until the matching
``}''

 
Any
``}''

escaped by a backslash or within a quoted string, and characters in
embedded arithmetic expansions, command substitutions, and variable
expansions, are not examined in determining the matching
``}''

 
<P>

The simplest form for parameter expansion is:
<P>


<BLOCKQUOTE><TT>${parameter}</TT></BLOCKQUOTE>
<P>

The value, if any, of parameter is substituted.
<P>

The parameter name or symbol can be enclosed in braces, which are
optional except for positional parameters with more than one digit or
when parameter is followed by a character that could be interpreted as
part of the name.
If a parameter expansion occurs inside
double-quotes:
<OL><P>

<LI>

Pathname expansion is not performed on the results of the
expansion.
<LI>

Field splitting is not performed on the results of the
expansion, with the exception of @.
</OL><P>

<P>

In addition, a parameter expansion can be modified by using one of the
following formats.
<DL COMPACT>
<P>

<DT><B>${parameter:-word}</B>
<DD>
Use Default Values.  If parameter is unset or null, the expansion of word
is substituted; otherwise, the value of parameter is substituted.
<DT><B>${parameter:=word}</B>
<DD>
Assign Default Values.  If parameter is unset or null, the expansion of
word is assigned to parameter.  In all cases, the final value of parameter
is substituted.  Only variables, not positional parameters or special
parameters, can be assigned in this way.
<DT><B>${parameter:?[word]}</B>
<DD>
Indicate Error if Null or Unset.  If parameter is unset or null, the
expansion of word (or a message indicating it is unset if word is omitted)
is written to standard error and the shell exits with a nonzero exit
status.  Otherwise, the value of parameter is substituted.  An interactive
shell need not exit.
<DT><B>${parameter:+word}</B>
<DD>
Use Alternative Value.  If parameter is unset or null, null is
substituted; otherwise, the expansion of word is substituted.
</DL>
<P>

<P>

In the parameter expansions shown previously, use of the colon in the
format results in a test for a parameter that is unset or null; omission
of the colon results in a test for a parameter that is only unset.
<DL COMPACT>
<P>

<DT><B>${#parameter}</B>
<DD>
String Length.  The length in characters of
the value of parameter.
</DL>
<P>

<P>

The following four varieties of parameter expansion provide for substring
processing.  In each case, pattern matching notation (see Shell Patterns),
rather than regular expression notation, is used to evaluate the patterns.
If parameter is * or @, the result of the expansion is unspecified.
Enclosing the full parameter expansion string in double-quotes does not
cause the following four varieties of pattern characters to be quoted,
whereas quoting characters within the braces has this effect.
<DL COMPACT>
<P>

<DT><B>${parameter%word}</B>
<DD>
Remove Smallest Suffix Pattern.  The word is expanded to produce a
pattern.  The parameter expansion then results in parameter, with the
smallest portion of the suffix matched by the pattern deleted.
<DT><B>${parameter%%word}</B>
<DD>
Remove Largest Suffix Pattern.  The word is expanded to produce a pattern.
The parameter expansion then results in parameter, with the largest
portion of the suffix matched by the pattern deleted.
<DT><B>${parameter#word}</B>
<DD>
Remove Smallest Prefix Pattern.  The word is expanded to produce a
pattern.  The parameter expansion then results in parameter, with the
smallest portion of the prefix matched by the pattern deleted.
<DT><B>${parameter##word}</B>
<DD>
Remove Largest Prefix Pattern.  The word is expanded to produce a pattern.
The parameter expansion then results in parameter, with the largest
portion of the prefix matched by the pattern deleted.
</DL>
<P>

<A NAME="lbBI">&nbsp;</A>
<H3>Command Substitution</H3>

Command substitution allows the output of a command to be substituted in
place of the command name itself.  Command substitution occurs when
the command is enclosed as follows:
<P>


<BLOCKQUOTE><TT>$(command)</TT></BLOCKQUOTE>
<P>

or
Po ``backquoted''



version
Pc :

<P>


<BLOCKQUOTE><TT>`command`</TT></BLOCKQUOTE>
<P>

The shell expands the command substitution by executing command in a
subshell environment and replacing the command substitution with the
standard output of the command, removing sequences of one or more
&lt;newline&gt;s at the end of the substitution.  (Embedded &lt;newline&gt;s before
the end of the output are not removed; however, during field splitting,
they may be translated into &lt;space&gt;s, depending on the value of
<B>IFS</B>

and quoting that is in effect.)
<A NAME="lbBJ">&nbsp;</A>
<H3>Arithmetic Expansion</H3>

<P>

Arithmetic expansion provides a mechanism for evaluating an arithmetic
expression and substituting its value. The format for arithmetic
expansion is as follows:
<P>


<BLOCKQUOTE><TT>$((expression))</TT></BLOCKQUOTE>
<P>

The expression is treated as if it were in double-quotes, except
that a double-quote inside the expression is not treated specially.  The
shell expands all tokens in the expression for parameter expansion,
command substitution, and quote removal.
<P>

Next, the shell treats this as an arithmetic expression and
substitutes the value of the expression.
<A NAME="lbBK">&nbsp;</A>
<H3>White Space Splitting (Field Splitting)</H3>

After parameter expansion, command substitution, and
arithmetic expansion the shell scans the results of
expansions and substitutions that did not occur in double-quotes for
field splitting and multiple fields can result.
<P>

The shell treats each character of the
<B>IFS</B>

as a delimiter and use the delimiters to split the results of parameter
expansion and command substitution into fields.
<A NAME="lbBL">&nbsp;</A>
<H3>Pathname Expansion (File Name Generation)</H3>

Unless the
-<B>f</B>

flag is set, file name generation is performed after word splitting is
complete.  Each word is viewed as a series of patterns, separated by
slashes.  The process of expansion replaces the word with the names of all
existing files whose names can be formed by replacing each pattern with a
string that matches the specified pattern. There are two restrictions on
this: first, a pattern cannot match a string containing a slash, and
second, a pattern cannot match a string starting with a period unless the
first character of the pattern is a period. The next section describes the
patterns used for both Pathname Expansion and the
<A HREF="../man1/case.1.php">case</A>(1)


command.
<A NAME="lbBM">&nbsp;</A>
<H3>Shell Patterns</H3>

A pattern consists of normal characters, which match themselves,
and meta-characters.   The meta-characters are
``!''

 
``*''

 
``?''

 
and
``[''

 
These characters lose their special meanings if they are quoted.  When
command or variable substitution is performed and the dollar sign or back
quotes are not double quoted, the value of the variable or the output of
the command is scanned for these characters and they are turned into
meta-characters.
<P>

An asterisk
(``*''

)

matches any string of characters.  A question mark matches any single
character. A left bracket
(``[''

)

introduces a character class.  The end of
the character class is indicated by a
(``]''

)

 
if the
``]''

is missing then the
``[''

matches a
``[''

rather than introducing a character class.  A character class matches any
of the characters between the square brackets.  A range of characters may
be specified using a minus sign. The character class may be complemented
by making an exclamation point the first character of the character class.
<P>

To include a
``]''

in a character class, make it the first character listed (after the
``!''

 
if any).  To include a minus sign, make it the first or last character listed
<A NAME="lbBN">&nbsp;</A>
<H3>Builtins</H3>

<P>

This section lists the builtin commands which are builtin because they
need to perform some operation that can't be performed by a separate
process. In addition to these, there are several other commands that may
be builtin for efficiency (e.g.
<A HREF="../man1/printf.1.php">printf</A>(1),


<A HREF="../man1/echo.1.php">echo</A>(1),


<A HREF="../man1/test.1.php">test</A>(1),


etc).
<DL COMPACT>
<P>

<DT><B>:</B>
<DD>
A null command that returns a 0 (true) exit value.
<DT><B>. file</B>
<DD>
The commands in the specified file are read and executed by the shell.
<DT><B>alias </B>[<I>name </I><B></B>[<I>=string ...</I>

]





]


<DD>
If
<I>name=string</I>

is specified, the shell defines the alias
<I>name</I>

with value
<I>string</I>

 
If just
<I>name</I>

is specified, the value of the alias
<I>name</I>

is printed. With no arguments, the
<B>alias</B>

builtin prints the
names and values of all defined aliases (see
<B>unalias )</B>

 
<DT><B>bg [ </B><I>job ] ...</I>


<DD>
Continue the specified jobs (or the current job if no
jobs are given) in the background.
<DT><B>command </B><I>command arg...</I>




<DD>
Execute the specified builtin command.  (This is useful when you
have a shell function with the same name as a builtin command.)
<DT><B>cd </B>[<I>directory</I>

]


<DD>
Switch to the specified directory (default
<B>$HOME )</B>

 
If an entry for
<B>CDPATH</B>

appears in the environment of the
<B>cd</B>

command or the shell variable
<B>CDPATH</B>

is set and the directory name does not begin with a slash, then the
directories listed in
<B>CDPATH</B>

will be searched for the specified directory.  The format of
<B>CDPATH</B>

is the same as that of
<B>PATH</B>

 
In an interactive shell, the
<B>cd</B>

command will print out the name of the
directory that it actually switched to if this is different from the name
that the user gave.  These may be different either because the
<B>CDPATH</B>

mechanism was used or because a symbolic link was crossed.
<DT><B>eval </B><I>string...</I>


<DD>
Concatenate all the arguments with spaces.  Then re-parse and execute
the command.
<DT><B>exec </B>[<I>command arg...</I>

]


<DD>
Unless command is omitted, the shell process is replaced with the
specified program (which must be a real program, not a shell builtin or
function).  Any redirections on the
<B>exec</B>

command are marked as permanent, so that they are not undone when the
<B>exec</B>

command finishes.
<DT><B>exit </B>[<I>exitstatus</I>

]


<DD>
Terminate the shell process.  If
<I>exitstatus</I>

is given it is used as the exit status of the shell; otherwise the
exit status of the preceding command is used.
<DT><B>export </B><I>name...</I>


<DD>
<DT><B>export -p</B>


<DD>
The specified names are exported so that they will appear in the
environment of subsequent commands. The only way to un-export a variable
is to unset it. The shell allows the value of a variable to be set at the
same time it is exported by writing
<P>


<BLOCKQUOTE><TT>export name=value</TT></BLOCKQUOTE>
<P>

With no arguments the export command lists the names of all exported variables.
With the
-<B>p</B>

option specified the output will be formatted suitably for non-interactive use.
<DT><B>fg </B>[<I>job</I>

]


<DD>
Move the specified job or the current job to the foreground.
<DT><B>getopts </B><I>optstring var</I>


<DD>
The
<B>POSIX</B>

<B>getopts</B>

command, not to be confused with the
<I>Bell Labs</I>

-derived
<A HREF="../man1/getopt.1.php">getopt</A>(1).


<P>

The first argument should be a series of letters, each of which may be
optionally followed by a colon to indicate that the option requires an
argument.  The variable specified is set to the parsed option.
<P>

The
<B>getopts</B>

command deprecates the older
<A HREF="../man1/getopt.1.php">getopt</A>(1)


utility due to its handling of arguments containing whitespace.
<P>

The
<B>getopts</B>

builtin may be used to obtain options and their arguments
from a list of parameters.  When invoked,
<B>getopts</B>

places the value of the next option from the option string in the list in
the shell variable specified by
<I>var</I>

and it's index in the shell variable
<B>OPTIND</B>

 
When the shell is invoked,
<B>OPTIND</B>

is initialized to 1.  For each option that requires an argument, the
<B>getopts</B>

builtin will place it in the shell variable
<B>OPTARG</B>

 
If an option is not allowed for in the
<I>optstring</I>

 
then
<B>OPTARG</B>

will be unset.
<P>

<I>optstring</I>

is a string of recognized option letters (see
<A HREF="../man3/getopt.3.php">getopt</A>(3)).


If a letter is followed by a colon, the option is expected to have an
argument which may or may not be separated from it by white space.  If an
option character is not found where expected,
<B>getopts</B>

will set the variable
<I>var</I>

to a
``?''

 
<B>getopts</B>

will then unset
<B>OPTARG</B>

and write output to standard error.  By specifying a colon as the
first character of
<I>optstring</I>

all errors will be ignored.
<P>

A nonzero value is returned when the last option is reached.
If there are no remaining arguments,
<B>getopts</B>

will set
<I>var</I>

to the special option,
``--''

 
otherwise, it will set
<I>var</I>

to
``?''

 
<P>

The following code fragment shows how one might process the arguments
for a command that can take the options
[a]

and
[b]

 
and the option
[c]

 
which requires an argument.
<P>


<BLOCKQUOTE>
<PRE>
while getopts abc: f
do
        case $f in
        a | b)  flag=$f;;
        c)      carg=$OPTARG;;
        \?)     echo $USAGE; exit 1;;
        esac
done
shift `expr $OPTIND - 1`
</PRE>
</BLOCKQUOTE>

<P>

This code will accept any of the following as equivalent:
<P>


<BLOCKQUOTE>
<PRE>
cmd -acarg file file
cmd -a -c arg file file
cmd -carg -a file file
cmd -a -carg -- file file
</PRE>
</BLOCKQUOTE>

<DT><B>hash -rv </B><I>command...</I>




<DD>
The shell maintains a hash table which remembers the
locations of commands.  With no arguments whatsoever,
the
<B>hash</B>

command prints out the contents of this table.  Entries which have not
been looked at since the last
<B>cd</B>

command are marked with an asterisk; it is possible for these entries
to be invalid.
<P>

With arguments, the
<B>hash</B>

command removes the specified commands from the hash table (unless
they are functions) and then locates them.  With the
-<B>v</B>

option, hash prints the locations of the commands as it finds them.  The
-<B>r</B>

option causes the hash command to delete all the entries in the hash table
except for functions.
<DT><B>jobs</B>
<DD>
This command lists out all the background processes
which are children of the current shell process.
<DT><B>pwd</B>
<DD>
Print the current directory.  The builtin command may
differ from the program of the same name because the
builtin command remembers what the current directory
is rather than recomputing it each time.  This makes
it faster.  However, if the current directory is
renamed, the builtin version of
<B>pwd</B>

will continue to print the old name for the directory.
<DT><B>
read </B>[-<B>p </B><I>prompt</I>



]



[-<B>r</B>

]

<I>variable...</I>

<DD>

<DD>The prompt is printed if the
-<B>p</B>

option is specified and the standard input is a terminal.  Then a line is
read from the standard input.  The trailing newline is deleted from the
line and the line is split as described in the section on word splitting
above, and the pieces are assigned to the variables in order.
At least one variable must be specified.
If there are
more pieces than variables, the remaining pieces (along with the
characters in
<B>IFS</B>

that separated them) are assigned to the last variable. If there are more
variables than pieces, the remaining variables are assigned the null
string. The
<B>read</B>

builtin will indicate success unless EOF is encountered on input, in
which case failure is returned.
<P>

By default, unless the
-<B>r</B>

option is specified, the backslash
``\''

acts as an escape character, causing the following character to be treated
literally.  If a backslash is followed by a newline, the backslash and the
newline will be deleted.
<DT><B>readonly </B><I>name...</I>


<DD>
<DT><B>readonly -p</B>


<DD>
The specified names are marked as read only, so that they cannot be
subsequently modified or unset.  The shell allows the value of a variable
to be set at the same time it is marked read only by writing
<P>


<BLOCKQUOTE><TT>readonly name=value</TT></BLOCKQUOTE>
<P>

With no arguments the readonly command lists the names of all read only
variables.
With the
-<B>p</B>

option specified the output will be formatted suitably for non-interactive use.
<P>

<DT><B>
set</B>

[{
-<B>options | +options | --</B>





 
<I>arg...</I>

]
<DD>

<DD>The
<B>set</B>

command performs three different functions.
<P>

With no arguments, it lists the values of all shell
variables.
<P>

If options are given, it sets the specified option
flags, or clears them as described in the section
called
Sx Argument List Processing .

<P>

The third use of the set command is to set the values of the shell's
positional parameters to the specified args.  To change the positional
parameters without changing any options, use
``--''

as the first argument to set.  If no args are present, the set command
will clear all the positional parameters (equivalent to executing
``shift $# .''

 
<DT><B>setvar </B><I>variable value</I>




<DD>
Assigns value to variable. (In general it is better to write
variable=value rather than using
<B>setvar</B>

 
<B>setvar </B>

is intended to be used in
functions that assign values to variables whose names are passed as
parameters.)
<DT><B>shift </B>[<I>n</I>

]


<DD>
Shift the positional parameters n times.  A
<B>shift</B>

sets the value of
<I>$1</I>

to the value of
<I>$2</I>

 
the value of
<I>$2</I>

to the value of
<I>$3</I>

 
and so on, decreasing
the value of
<I>$#</I>

by one. If n is greater than the number of positional parameters,
<B>shift</B>

will issue an error message, and exit with return status 2.
<DT><B>times</B>
<DD>
Print the accumulated user and system times for the shell and for processes
run from the shell.  The return status is 0.
<DT><B>
trap</B>

<I>action</I>

<I>signal...</I>

<DD>

<DD>Cause the shell to parse and execute action when any of the specified
signals are received. The signals are specified by signal number. If
<I>signal</I>

is
<B>0</B>

 
the action is executed when the shell exits.
<I>action</I>

may be null or
``-''

 
the former causes the specified signal to be
ignored and the latter causes the default action to be taken. When the
shell forks off a subshell, it resets trapped (but not ignored) signals to
the default action. The
<B>trap</B>

command has no effect on signals that were
ignored on entry to the shell.
<DT><B>type </B>[<I>name ...</I>

]


<DD>
Interpret each name as a command and print the resolution of the command
search. Possible resolutions are:
shell keyword, alias, shell builtin,
command, tracked alias and not found.  For aliases the alias expansion is
printed; for commands and tracked aliases the complete pathname of the
command is printed.
<DT><B>ulimit 
</B>

[-<B>H  -S</B>



]

[-<B>a  -tfdscmlpn </B>[<I>value</I>

]





]

<DD>

<DD>Inquire about or set the hard or soft limits on processes or set new
limits. The choice between hard limit (which no process is allowed to
violate, and which may not be raised once it has been lowered) and soft
limit (which causes processes to be signaled but not necessarily killed,
and which may be raised) is made with these flags:
<DL COMPACT>
<P>

<DT><B>-H</B>


<DD>
set or inquire about hard limits
<DT><B>-S</B>


<DD>
set or inquire about soft limits. If neither
-<B>H</B>

nor
-<B>S</B>

is specified, the soft limit is displayed or both limits are set. If both
are specified, the last one wins.
</DL>
<P>

<P>

<DL COMPACT>
<P>

The limit to be interrogated or set, then, is chosen by specifying
any one of these flags:
<DT><B>-a</B>


<DD>
show all the current limits
<DT><B>-t</B>


<DD>
show or set the limit on CPU time (in seconds)
<DT><B>-f</B>


<DD>
show or set the limit on the largest file that can be created
(in 512-byte blocks)
<DT><B>-d</B>


<DD>
show or set the limit on the data segment size of a process (in kilobytes)
<DT><B>-s</B>


<DD>
show or set the limit on the stack size of a process (in kilobytes)
<DT><B>-c</B>


<DD>
show or set the limit on the largest core dump size that can be produced
(in 512-byte blocks)
<DT><B>-m</B>


<DD>
show or set the limit on the total physical memory that can be
in use by a process (in kilobytes)
<DT><B>-l</B>


<DD>
show or set the limit on how much memory a process can lock with
<A HREF="../man2/mlock.2.php">mlock</A>(2)


(in kilobytes)
<DT><B>-p</B>


<DD>
show or set the limit on the number of processes this user can
have at one time
<DT><B>-n</B>


<DD>
show or set the limit on the number files a process can have open at once
</DL>
<P>

<P>

If none of these is specified, it is the limit on file size that is shown
or set. If value is specified, the limit is set to that number; otherwise
the current limit is displayed.
<P>

Limits of an arbitrary process can be displayed or set using the
<A HREF="../man8/sysctl.8.php">sysctl</A>(8)


utility.
<P>

<DT><B>umask </B>[<I>mask</I>

]


<DD>
Set the value of umask (see
<A HREF="../man2/umask.2.php">umask</A>(2))


to the specified octal value. If the argument is omitted, the umask value
is printed.
<DT><B>unalias 
</B>

[-<B>a</B>

]

[<I>name</I>

]

<DD>

<DD>If
<I>name</I>

is specified, the shell removes that alias. If
-<B>a</B>

is specified, all aliases are removed.
<DT><B>unset </B><I>name...</I>


<DD>
The specified variables and functions are unset and unexported. If a given
name corresponds to both a variable and a function, both the variable and
the function are unset.
<DT><B>wait </B>[<I>job</I>

]


<DD>
Wait for the specified job to complete and return the exit status of the
last process in the job. If the argument is omitted, wait for all jobs to
complete and the return an exit status of zero.
</DL>
</DL>
<A NAME="lbBO">&nbsp;</A>
<H2>ENVIRONMENT</H2>

<DL COMPACT>
<P>

<DT><B>HOME</B>


<DD>
Set automaticly by
<A HREF="../man1/login.1.php">login</A>(1)


from the user's login directory in the password file
(<A HREF="../man4/passwd.4.php">passwd</A>(4)

)

 
This environment variable also functions as the default argument for the
cd builtin.
<DT><B>PATH</B>


<DD>
The default search path for executables.  See the above section
Sx Path Search .

<DT><B>CDPATH</B>


<DD>
The search path used with the cd builtin.
<DT><B>MAIL</B>


<DD>
The name of a mail file, that will be checked for the arrival of new mail.
Overridden by
<B>MAILPATH</B>

 
<DT><B>MAILCHECK</B>


<DD>
The frequency in seconds that the shell checks for the arrival of mail
in the files specified by the
<B>MAILPATH</B>

or the
<B>MAIL</B>

file.  If set to 0, the check will occur at each prompt.
<DT><B>MAILPATH</B>


<DD>
A colon
``:''

separated list of file names, for the shell to check for incoming mail.
This environment setting overrides the
<B>MAIL</B>

setting.  There is a maximum of 10 mailboxes that can be monitored at once.
<DT><B>PS1</B>


<DD>
The primary prompt string, which defaults to
``$ &nbsp;''

 
unless you are the superuser, in which case it defaults to
``# &nbsp;''

 
<DT><B>PS2</B>


<DD>
The secondary prompt string, which defaults to
``&gt; &nbsp;''

 
<DT><B>IFS</B>


<DD>
Input Field Separators.  This is normally set to &lt;space&gt; &lt;tab&gt; and
&lt;newline&gt;.  See the
Sx White Space Splitting

section for more details.
<DT><B>TERM</B>


<DD>
The default terminal setting for the shell.  This is inherited by
children of the shell, and is used in the history editing modes.
<DT><B>HISTSIZE</B>


<DD>
The number of lines in the history buffer for the shell.
</DL>
<P>

<A NAME="lbBP">&nbsp;</A>
<H2>FILES</H2>

<DL COMPACT>
<P>

<DT><B>$HOME/.profile

</B>
<DD>
<DT><B>/etc/profile

</B>
<DD>
</DL>
<P>

<A NAME="lbBQ">&nbsp;</A>
<H2>SEE ALSO</H2>

<A HREF="../man1/csh.1.php">csh</A>(1),


<A HREF="../man1/getopt.1.php">getopt</A>(1),


<A HREF="../man1/ksh.1.php">ksh</A>(1),


<A HREF="../man1/login.1.php">login</A>(1),


<A HREF="../man1/test.1.php">test</A>(1),


<A HREF="../man3/getopt.3.php">getopt</A>(3),


<A HREF="../man4/passwd.4.php">passwd</A>(4),


<A HREF="../man4/profile.4.php">profile</A>(4),


<A HREF="../man5/environ.5.php">environ</A>(5)


<A HREF="../man8/sysctl.8.php">sysctl</A>(8)


<A NAME="lbBR">&nbsp;</A>
<H2>HISTORY</H2>

A
<B>sh</B>


command appeared in
AT&amp;T System
v1 .
It was, however, unmaintainable so we wrote this one.
<A NAME="lbBS">&nbsp;</A>
<H2>EXIT STATUS</H2>

Errors that are detected by the shell, such as a syntax error, will cause the
shell to exit with a non-zero exit status.  If the shell is not an
interactive shell, the execution of the shell file will be aborted.  Otherwise
the shell will return the exit status of the last command executed, or
if the exit builtin is used with a numeric argument, it will return the
argument.
<A NAME="lbBT">&nbsp;</A>
<H2>BUGS</H2>

Setuid shell scripts should be avoided at all costs, as they are a
significant security risk.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAE">Overview</A><DD>
<DT><A HREF="#lbAF">Invocation</A><DD>
<DT><A HREF="#lbAG">Argument List Processing</A><DD>
<DT><A HREF="#lbAH">Lexical Structure</A><DD>
<DT><A HREF="#lbAI">Quoting</A><DD>
<DT><A HREF="#lbAJ">Backslash</A><DD>
<DT><A HREF="#lbAK">Single Quotes</A><DD>
<DT><A HREF="#lbAL">Double Quotes</A><DD>
<DT><A HREF="#lbAM">Reserved Words</A><DD>
<DT><A HREF="#lbAN">Aliases</A><DD>
<DT><A HREF="#lbAO">Commands</A><DD>
<DT><A HREF="#lbAP">Simple Commands</A><DD>
<DT><A HREF="#lbAQ">Redirections</A><DD>
<DT><A HREF="#lbAR">Search and Execution</A><DD>
<DT><A HREF="#lbAS">Path Search</A><DD>
<DT><A HREF="#lbAT">Command Exit Status</A><DD>
<DT><A HREF="#lbAU">Complex Commands</A><DD>
<DT><A HREF="#lbAV">Pipelines</A><DD>
<DT><A HREF="#lbAW">Background Commands -- &amp;</A><DD>
<DT><A HREF="#lbAX">Lists -- Generally Speaking</A><DD>
<DT><A HREF="#lbAY">Short-Circuit List Operators</A><DD>
<DT><A HREF="#lbAZ">Flow-Control Constructs -- if, while, for, case</A><DD>
<DT><A HREF="#lbBA">Grouping Commands Together</A><DD>
<DT><A HREF="#lbBB">Functions</A><DD>
<DT><A HREF="#lbBC">Variables and Parameters</A><DD>
<DT><A HREF="#lbBD">Positional Parameters</A><DD>
<DT><A HREF="#lbBE">Special Parameters</A><DD>
<DT><A HREF="#lbBF">Word Expansions</A><DD>
<DT><A HREF="#lbBG">Tilde Expansion (substituting a user's home directory)</A><DD>
<DT><A HREF="#lbBH">Parameter Expansion</A><DD>
<DT><A HREF="#lbBI">Command Substitution</A><DD>
<DT><A HREF="#lbBJ">Arithmetic Expansion</A><DD>
<DT><A HREF="#lbBK">White Space Splitting (Field Splitting)</A><DD>
<DT><A HREF="#lbBL">Pathname Expansion (File Name Generation)</A><DD>
<DT><A HREF="#lbBM">Shell Patterns</A><DD>
<DT><A HREF="#lbBN">Builtins</A><DD>
</DL>
<DT><A HREF="#lbBO">ENVIRONMENT</A><DD>
<DT><A HREF="#lbBP">FILES</A><DD>
<DT><A HREF="#lbBQ">SEE ALSO</A><DD>
<DT><A HREF="#lbBR">HISTORY</A><DD>
<DT><A HREF="#lbBS">EXIT STATUS</A><DD>
<DT><A HREF="#lbBT">BUGS</A><DD>
</DL>

</div>






</div>




</body>
</html>
