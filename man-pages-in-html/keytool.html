
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<title>keytool</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="/global/main.css" title="default">
</head>

<body>



<div id="container">


<div id="content">

<div id='catHeader'><table width='100%'><tr><td>
<H1>keytool</H1>
Section: User Commands  (1)<BR>Updated: 13 June 2000<BR>
</td><td align='right' valign='bottom'><div class='ad_header_right'></div></td></tr></table></div></div>
<div id='categories'>
<div class='ad_man_right'>
</div>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

keytool - key and certificate management tool
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<B>keytool</B>

[
<I>subcommands</I> ]

<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAB"></A>
<A NAME="ixAAC"></A>
<B>keytool</B>

is a key and certificate management utility. It enables
users to administer their own public/private key pairs and
associated certificates for use in self-authentication (where the
user authenticates himself/herself to other users/services) or
data integrity and authentication services, using digital
signatures. It also allows users to cache the public keys (in the
form of certificates) of their communicating peers.
<P>

A certificate is a digitally signed statement from one entity
(person, company, and so forth), saying that the public key (and some
other information) of some other entity has a particular value.
(See Certificates.) When data is digitally signed, the signature
can be verified to check the data integrity and authenticity.
Integrity means that the data has not been modified or tampered
with, and authenticity means the data indeed comes from whoever
claims to have created and signed it.
<P>

<B>keytool</B>

stores the keys and certificates in a so-called keystore.
The 
<B>keytool</B>

default keystore implementation implements the keystore as a
file. It protects private keys with a password.
<P>

The 
<B><A HREF="../man1/jarsigner.1.php">jarsigner</A></B>(1)

tool uses information from a keystore to generate or
verify digital signatures for Java ARchive (JAR) files. (A JAR
file packages class files, images, sounds, and/or other digital
data in a single file). 
<B><A HREF="../man1/jarsigner.1.php">jarsigner</A></B>(1)

verifies the digital signature
of a JAR file, using the certificate that comes with it (it is
included in the signature block file of the JAR file), and then
checks whether or not the public key of that certificate is
&quot;trusted&quot;, that is, is contained in the specified keystore.
<P>

Please note: the 
<B>keytool</B>

and 
<B><A HREF="../man1/jarsigner.1.php">jarsigner</A></B>(1)

tools completely replace
the javakey tool provided in JDK 1.1. These new tools provide more
features than javakey, including the ability to protect the
keystore and private keys with passwords, and the ability to
verify signatures in addition to generating them. The new keystore
architecture replaces the identity database that javakey created
and managed. It is possible to import the information from an
identity database into a keystore, via the 
<B>-identitydb</B>

subcommand.
<A NAME="lbAE">&nbsp;</A>
<H3>Keystore Entries</H3>

<A NAME="ixAAD"></A>
There are two different types of entries in a keystore:
<DL COMPACT>
<DT>1. <DD>
key entries---each holds very sensitive
cryptographic key information, which is stored in a
protected format to prevent unauthorized access.
Typically, a key stored in this type of entry is a
secret key, or a private key accompanied by the
certificate &quot;chain&quot; for the corresponding public
key. The 
<B>keytool</B>

and 
<B><A HREF="../man1/jarsigner.1.php">jarsigner</A></B>(1)

tools only handle
the latter type of entry, that is, private keys and
their associated certificate chains.
<DT>2. <DD>
trusted certificate entries---each contains a
single public key certificate belonging to another
party. It is called a &quot;trusted certificate&quot; because
the keystore owner trusts that the public key in
the certificate indeed belongs to the identity
identified by the &quot;subject&quot; (owner) of the
certificate. The issuer of the certificate vouches
for this, by signing the certificate.
</DL>
<A NAME="lbAF">&nbsp;</A>
<H3>Keystore Aliases</H3>

<A NAME="ixAAE"></A>
All keystore entries (key and trusted certificate
entries) are accessed via unique aliases. Aliases are
case-insensitive; the aliases Hugo and hugo would refer
to the same keystore entry.
<P>

An alias is specified when you add an entity to the
keystore using the 
<B>-genkey</B>

subcommand to generate a key
pair (public and private key) or the 
<B>-import</B>

subcommand to
add a certificate or certificate chain to the list of
trusted certificates. Subsequent 
<B>keytool</B>

commands must
use this same alias to refer to the entity.
<P>

For example, suppose you use the alias duke to generate
a new public/private key pair and wrap the public key
into a self-signed certificate (see Certificate Chains)
via the following command:
<P>

<B>
</B><PRE>
example% keytool -genkey -alias duke -keypass dukekeypasswd
</PRE>


<P>

This specifies an inital password of 
<B>dukekeypasswd</B>

required by subsequent commands to access the private
key assocated with the alias 
<B>duke</B>.

If you later want to
change
<B>duke</B>'s

private key password, you use a command
like the following:
<P>

<B>
</B><PRE>
example% keytool -keypasswd -alias duke -keypass\        dukekeypasswd -new newpass</PRE>


<P>

This changes the password from &quot;dukekeypasswd&quot; to<BR>
&quot;newpass&quot;.
<P>

Please note: A password should not actually be specified
on a command line or in a script unless it is for
testing purposes, or you are on a secure system. If you
don't specify a required password option on a command
line, you will be prompted for it.
When typing in a
password at the password prompt, the password is
currently echoed (displayed exactly as typed), so be
careful not to type it in front of anyone.
<A NAME="lbAG">&nbsp;</A>
<H3>Keystore Location</H3>

<A NAME="ixAAF"></A>
Each 
<B>keytool</B>

command has a 
<B>-keystore</B>

option for
specifying the name and location of the persistent
keystore file for the keystore managed by 
<B>keytool</B>.

The
keystore is by default stored in a file named 
<B>.keystore</B>

in the user's home directory, as determined by the
&quot;user.home&quot; system property.
<A NAME="lbAH">&nbsp;</A>
<H3>Keystore Creation</H3>

<A NAME="ixAAG"></A>
A keystore is created whenever you use a 
<B>-genkey</B>,

<B>-import</B>,

or 
<B>-identitydb</B>

subcommand to add data to a
keystore that doesn't yet exist.
<P>

More specifically, if you specify, in the 
<B>-keystore</B>

option, a keystore that doesn't yet exist, that keystore
will be created.
<P>

If you don't specify a 
<B>-keystore</B>

option, the default
keystore is a file named 
<B>.keystore </B>

in your home
directory.
If that file does not yet exist, it will be created.
<A NAME="lbAI">&nbsp;</A>
<H3>Keystore Implementation</H3>

<A NAME="ixAAH"></A>
The 
<B>KeyStore</B>

class provided in the java.security package
supplies well-defined interfaces to access and modify
the information in a keystore.
It is possible for there
to be multiple different concrete implementations, where
each implementation is that for a particular type of
keystore.
<P>

Currently, there are two command-line tools (<B>keytool</B>
and 
<B><A HREF="../man1/jarsigner.1.php">jarsigner</A></B>(1))

and also a GUI-based tool named
<B>policytool</B>.

Since
<B>KeyStore</B>

is publicly available, JDK users can write
additional security applications that use it.
<P>

There is a built-in default implementation, provided by
Sun Microsystems.
It implements the keystore as a file,
utilizing a proprietary keystore type (format) named
&quot;JKS&quot;.
It protects each private key with its individual
password, and also protects the integrity of the entire
keystore with a (possibly different) password.
<P>

Keystore implementations are provider-based.
More specifically, the application interfaces supplied by
<B>KeyStore</B>

are implemented in terms of a &quot;Service Provider
Interface&quot; (SPI).
That is, there is a corresponding abstract 
<B>KeystoreSpi </B>

class, also in the java.security
package, which defines the Service Provider Interface
methods that &quot;providers&quot; must implement.
(The term &quot;provider&quot; refers to a package or a set of packages that
supply a concrete implementation of a subset of services
that can be accessed by the Java Security API.)  Thus, to
provide a keystore implementation, clients must
implement a &quot;provider&quot; and supply a 
<B>KeystoreSpi</B>

subclass
implementation, as described in How to Implement a
Provider for the Java Cryptography Architecture.
<P>

Applications can choose different types of keystore
implementations from different providers, using the
&quot;getInstance&quot; factory method supplied in the 
<B>KeyStore</B>

class. A keystore type defines the storage and data
format of the keystore information, and the algorithms
used to protect private keys in the keystore and the
integrity of the keystore itself. Keystore
implementations of different types are not compatible.
<P>

<B>keytool</B>

works on any file-based keystore implementation.
(It treats the keytore location that is passed to it at
the command line as a filename and converts it to a
FileInputStream, from which it loads the keystore
information.) The 
<B><A HREF="../man1/jarsigner.1.php">jarsigner</A></B>(1)

and policytool tools, on the
other hand, can read a keystore from any location that
can be specified using a URL.
<P>

For 
<B>keytool</B>

and 
<B><A HREF="../man1/jarsigner.1.php">jarsigner</A></B>(1),

you can specify a keystore
type at the command line, via the 
<B>-storetype</B>

option.
For
<B>Policy Tool</B>,

you can specify a keystore type via the
&quot;Change Keystore&quot; command in the Edit menu.
<P>

If you don't explicitly specify a keystore type, the
tools choose a keystore implementation based simply on
the value of the keystore.type property specified in the
security properties file.
The security properties file is called 
<B>java.security</B>,

and it resides in the JDK
security properties directory, 
<B>java.home/lib/security</B>,

where java.home is the JDK installation directory.
<P>

Each tool gets the keystore.type value and then examines
all the currently-installed providers until it finds one
that implements keystores of that type. It then uses the
keystore implementation from that provider.
<P>

The 
<B>KeyStore</B>

class defines a static method named
getDefaultType that lets applications and applets
retrieve the value of the 
<B>keystore.type </B>

property. The
following line of code creates an instance of the
default keystore type (as specified in the 
<B>keystore.type</B>

property):
<P>

<B>
</B><PRE>
KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
</PRE>


<P>

The default keystore type is &quot;jks&quot; (the proprietary type
of the keystore implementation provided by Sun). This is
specified by the following line in the security
properties file:
<P>

<B>
</B><PRE>
keystore.type=jks
</PRE>


<P>

To have the tools utilize a keystore implementation
other than the default, you can change that line to
specify a different keystore type.
<P>

For example, if you have a provider package that
supplies a keystore implementation for a keystore type
called &quot;pkcs12&quot;, change the line to
<P>

<B>
</B><PRE>
keystore.type=pkcs12
</PRE>


<P>

Note: case doesn't matter in keystore type designations.
For example, &quot;JKS&quot; would be considered the same as
&quot;jks&quot;.
<A NAME="lbAJ">&nbsp;</A>
<H3>Supported Algorithms and Key Sizes</H3>

<A NAME="ixAAI"></A>
<B>keytool</B>

allows users to specify any key pair generation
and signature algorithm supplied by any of the
registered cryptographic service providers. That is, the
<B>-keyalg</B>

and 
<B>-sigalg</B>

options for various subcommands must be
supported by a provider implementation. The default key
pair generation algorithm is &quot;DSA&quot;. The signature
algorithm is derived from the algorithm of the
underlying private key: If the underlying private key is
of type &quot;DSA&quot;, the default signature algorithm is
&quot;SHA1withDSA&quot;, and if the underlying private key is of
type &quot;RSA&quot;, the default signature algorithm is
&quot;MD5withRSA&quot;.
<P>

When generating a DSA key pair, the key size must be in
the range from 512 to 1024 bits, and must be a multiple
of 64. The default key size for any algorithm is 1024
bits.
<A NAME="lbAK">&nbsp;</A>
<H3>Certificates</H3>

<A NAME="ixAAJ"></A>
A certificate (also known as a public-key certificate)
is a digitally signed statement from one entity (the
issuer), saying that the public key (and some other
information) of another entity (the subject) has some
<P>

Let us expand on some of the key terms used in this
sentence:
<DL COMPACT>
<DT><B>Public Keys</B>

<DD>
These are numbers associated with a particular
entity, and are intended to be known to everyone
who needs to have trusted interactions with that
entity. Public keys are used to verify signatures.
<DT><B>Digitally Signed</B>

<DD>
If some data is digitally signed it has been stored
with the &quot;identity&quot; of an entity, and a signature
that proves that entity knows about the data. The
data is rendered unforgeable by signing with the
entity's private key.
<DT><B>Identity</B>

<DD>
A known way of addressing an entity. In some
systems the identity is the public key, in others
it can be anything from a Unix UID to an Email
address to an X.509 Distinguished Name.
<DT><B>Signature</B>

<DD>
A signature is computed over some data using the
private key of an entity (the signer, which in the
case of a certificate is also known as the issuer).
<DT><B>Private Keys</B>

<DD>
These are numbers, each of which is supposed to be
known only to the particular entity whose private
key it is (that is, it's supposed to be kept
secret). Private and public keys exist in pairs in
all public key cryptography systems (also referred
to as &quot;public key crypto systems&quot;). In a typical
public key crypto system, such as DSA, a private
key corresponds to exactly one public key. Private
keys are used to compute signatures.
<DT><B>Entity</B>

<DD>
An entity is a person, organization, program,
computer, business, bank, or something else you are
trusting to some degree.
</DL>
<P>

Basically, public key cryptography requires access to
users' public keys. In a large-scale networked
environment it is impossible to guarantee that prior
relationships between communicating entities have been
established or that a trusted repository exists with all
used public keys. Certificates were invented as a
solution to this public key distribution problem. Now a
Certification Authority (CA) can act as a trusted third
party. CAs are entities (for example, businesses) that
are trusted to sign (issue) certificates for other
entities. It is assumed that CAs will only create valid
and reliable certificates, as they are bound by legal
agreements. There are many public Certification
Authorities, such as VeriSign, Thawte, Entrust, and so
on. You can also run your own Certification Authority
using products such as the Netscape/Microsoft
Certificate Servers or the Entrust CA product for your
organization.
<P>

Using 
<B>keytool</B>,

it is possible to display, import, and
export certificates. It is also possible to generate
self-signed certificates.
<P>

<B>keytool </B>

currently handles X.509 certificates.
<A NAME="lbAL">&nbsp;</A>
<H3>X.509 Certificates</H3>

<A NAME="ixAAK"></A>
The X.509 standard defines what information
can go into a certificate, and describes how
to write it down (the data format). All X.509
certificates have the following data, in
addition to the signature:
<P>

Version
This identifies which version of the
X.509 standard applies to this
certificate, which affects what
information can be specified in it. Thus
far, three versions are defined. 
<B>keytool</B>

can import and export v1, v2, and v3
certificates. It generates v1
certificates.
Serial Number
The entity that created the certificate
is responsible for assigning it a serial
number to distinguish it from other
certificates it issues. This information
is used in numerous ways, for example
when a certificate is revoked its serial
number is placed in a Certificate
Revocation List (CRL).
Signature Algorithm Identifier
This identifies the algorithm used by the
CA to sign the certificate.
Issuer Name
The X.500 Distinguished Name of the
entity that signed the certificate. This
is normally a CA. Using this certificate
implies trusting the entity that signed
this certificate. (Note that in some
cases, such as root or top-level CA
certificates, the issuer signs its own
certificate.)
Validity Period
Each certificate is valid only for a
limited amount of time. This period is
described by a start date and time and an
end date and time, and can be as short as
a few seconds or almost as long as a
century. The validity period chosen
depends on a number of factors, such as
the strength of the private key used to
sign the certificate or the amount one is
willing to pay for a certificate. This is
the expected period that entities can
rely on the public value, if the
associated private key has not been
compromised.
Subject Name
The name of the entity whose public key
the certificate identifies. This name
uses the X.500 standard, so it is
intended to be unique across the
Internet. This is the X.500 Distinguished
Name (DN) of the entity, for example,
<P>

<B>
</B><PRE>
CN=Java Duke, OU=Java Software Division, O=Sun Microsystems Inc, C=US
</PRE>


<P>

(These refer to the subject's Common
Name, Organizational Unit, Organization,
and Country.)
Subject Public Key Information
This is the public key of the entity
being named, together with an algorithm
identifier which specifies which public
key crypto system this key belongs to and
any associated key parameters.
<P>

<I>X.509 Version 1 </I>

has been available since 1988,
is widely deployed, and is the most generic.
<P>

<I>X.509 Version 2 </I>

introduced the concept of
subject and issuer unique identifiers to
handle the possibility of reuse of subject
and/or issuer names over time. Most
certificate profile documents strongly
recommend that names not be reused, and that
certificates should not make use of unique
identifiers. Version 2 certificates are not
widely used.
<P>

<I>X.509 Version 3 </I>

is the most recent (1996) and
supports the notion of extensions, whereby
anyone can define an extension and include it
in the certificate. Some common extensions in
use today are: KeyUsage (limits the use of the
keys to particular purposes such as
&quot;signing-only&quot;) and AlternativeNames (allows
other identities to also be associated with
this public key, for example, DNS names, Email
addresses, IP addresses). Extensions can be
marked critical to indicate that the extension
should be checked and enforced/used. For
example, if a certificate has the KeyUsage
extension marked critical and set to
&quot;keyCertSign&quot; then if this certificate is
presented during SSL communication, it should
be rejected, as the certificate extension
indicates that the associated private key
should only be used for signing certificates
and not for SSL use.
<P>

All the data in a certificate is encoded using
two related standards called ASN.1/DER.
<I>Abstract Syntax Notation 1 </I>

describes data. The
Definite Encoding Rules describe a single way
to store and transfer that data.
<A NAME="lbAM">&nbsp;</A>
<H3>X.500 Distinguished Names</H3>

<A NAME="ixAAL"></A>
X.500 Distinguished Names are used to identify
entities, such as those which are named by the
subject and issuer (signer) fields of X.509
certificates. 
<B>keytool</B>

supports the following subparts:
<DL COMPACT>
<DT>*<DD>
commonName---common name of a person,
for example, &quot;Susan Jones&quot;
<DT>*<DD>
organizationUnit---small organization
(for example, department or division) name, such as, &quot;Purchasing&quot;
<DT>* organizationName---large organization<DD>
name, for example, &quot;ABCSystems, Inc.&quot;
<DT>*<DD>
localityName---locality (city) name,
for example, &quot;Palo Alto&quot;
<DT>*<DD>
stateName---state or province name, for example,
&quot;California&quot;
<DT>*<DD>
country---two-letter country code, for example,
&quot;CH&quot;
</DL>
<P>

When supplying a distinguished name string as
the value of a
<B>-dname</B>

option, as for the
<B>-genkey </B>

or
<B>-selfcert</B>

subcommands, the string must
be in the following format:
<P>

<B>
</B><PRE>
CN=cName, OU=orgUnit, O=org, L=city, S=state, C=countryCode
</PRE>


<P>

where all the italicized items represent
actual values and the above keywords are
abbreviations for the following:
<P>

<B>
</B><PRE>
CN=commonName
OU=organizationUnit
O=organizationName
L=localityName
S=stateName
C=country
</PRE>


<P>

A sample distinguished name string is
<P>

<B>
</B><PRE>
CN=Mark Smith, OU=Java, O=Sun, L=Cupertino, S=California, C=US
</PRE>


<P>

and a sample command using such a string is
<P>

<B>
</B><PRE>
example% keytool -genkey -dname &quot;CN=Mark Smith, OU=Java, 
O=Sun, L=Cupertino, S=California, C=US&quot; -alias mark
</PRE>


<P>

Case does not matter for the keyword
abbreviations. For example, 
<B>CN</B>,

<B>cn</B>,

and
<B>Cn</B>

<BR>&nbsp;are&nbsp;all&nbsp;treated&nbsp;the&nbsp;same.
<P>

Order matters; each subcomponent must appear
in the designated order. However, it is not
necessary to have all the subcomponents. You
may use a subset, for example:
<P>

<B>
</B><PRE>
CN=Steve Meier, OU=SunSoft, O=Sun, C=US
</PRE>


<P>

If a distinguished name string value contains
a comma, it must be escaped by a &quot;\&quot;
character when you specify the string on
a command line, as in
<P>

<B>
</B><PRE>
cn=peter schuster, o=Sun Microsystems\, Inc., o=sun, c=us
</PRE>


<P>

It is never necessary to specify a
distinguished name string on a command line.
If it is needed for a command, but not
supplied on the command line, the user is
prompted for each of the subcomponents.
In this case, a comma does not need to be escaped
by a &quot;\&quot;
<A NAME="lbAN">&nbsp;</A>
<H3>The Internet RFC 1421 Certificate Encoding Standard</H3>

<A NAME="ixAAM"></A>
Certificates are often stored using the
printable encoding format defined by the
Internet RFC 1421 standard, instead of their
binary encoding. This certificate format, also
known as &quot;Base 64 encoding&quot;, facilitates
exporting certificates to other applications
by email or through some other mechanism.
<P>

Certificates read by the 
<B>-import</B>

and
<B>-printcert</B>

subcommands can be in either this
format or binary encoded.
<P>

The 
<B>-export</B>

subcommand by default outputs a
certificate in binary encoding, but will
instead output a certificate in the printable
encoding format, if the 
<B>-rfc</B>

option is
specified.
<P>

The 
<B>-list</B>

subcommand by default prints the MD5
fingerprint of a certificate. If the 
<B>-v</B>

option
is specified, the certificate is printed in
human-readable format, while if the 
<B>-rfc</B>

option is specified, the certificate is output
in the printable encoding format.
<P>

In its printable encoding format, the encoded
certificate is bounded at the beginning by
<P>

<B>
</B><PRE>
-----BEGIN CERTIFICATE-----
</PRE>


<P>

and at the end by
<P>

<B>
</B><PRE>
-----END CERTIFICATE-----
</PRE>


<A NAME="lbAO">&nbsp;</A>
<H3>Certificate Chains</H3>

<A NAME="ixAAN"></A>
<B>keytool</B>

can create and manage keystore &quot;key&quot;
entries that each contain a private key and an
associated certificate &quot;chain&quot;. The first
certificate in the chain contains the public
key corresponding to the private key.
<P>

When keys are first generated (see the 
<B>-genkey</B>

subcommand), the chain starts off containing a
single element, a self-signed certificate. A
self-signed certificate is one for which the
issuer (signer) is the same as the subject
(the entity whose public key is being
authenticated by the certificate). Whenever
the 
<B>-genkey</B>

subcommand is called to generate a
new public/private key pair, it also wraps the
public key into a self-signed certificate.
<P>

Later, after a Certificate Signing Request
(CSR) has been generated (see the 
<B>-certreq</B>

subcommand) and sent to a Certification Authority
(CA), the response from the CA is imported
(see 
<B>-import</B>),

and the self-signed certificate
is replaced by a chain of certificates. At the
bottom of the chain is the certificate (reply)
issued by the CA authenticating the subject's
public key. The next certificate in the chain
is one that authenticates the CA's public key.
<P>

In many cases, this is a self-signed
certificate (that is, a certificate from the
CA authenticating its own public key) and the
last certificate in the chain. In other cases,
the CA may return a chain of certificates. In
this case, the bottom certificate in the chain
is the same (a certificate signed by the CA,
authenticating the public key of the key
entry), but the second certificate in the
chain is a certificate signed by a different
CA, authenticating the public key of the CA
you sent the CSR to. Then, the next
certificate in the chain will be a certificate
authenticating the second CA's key, and so on,
until a self-signed &quot;root&quot; certificate is
reached. Each certificate in the chain (after
the first) thus authenticates the public key
of the signer of the previous certificate in
the chain.
<P>

Many CAs only return the issued certificate,
with no supporting chain, especially when
there is a flat hierarchy (no intermediates
CAs). In this case, the certificate chain must
be established from trusted certificate
information already stored in the keystore.
<P>

A different reply format (defined by the
PKCS#7 standard) also includes the supporting
certificate chain, in addition to the issued
certificate. Both reply formats can be handled
by 
<B>keytool</B>.

<P>

The top-level (root) CA certificate is
self-signed. However, the trust into the
root's public key does not come from the root
certificate itself (anybody could generate a
self-signed certificate with the distinguished
name of say, the VeriSign root CA!), but from
other sources like a newspaper. The root CA
public key is widely known. The only reason it
is stored in a certificate is because this is
the format understood by most tools, so the
certificate in this case is only used as a
&quot;vehicle&quot; to transport the root CA's public
key. Before you add the root CA certificate to
your keystore, you should view it (using the
-printcert option) and compare the displayed
fingerprint with the well-known fingerprint
(obtained from a newspaper, the root CA's
webpage, and so forth).
<A NAME="lbAP">&nbsp;</A>
<H3>Importing Certificates</H3>

<A NAME="ixAAO"></A>
To import a certificate from a file, use the
<B>-import</B>

subcommand, as in
<P>

<B>
</B><PRE>
example% keytool -import -alias joe -file jcertfile.cer
</PRE>


<P>

This sample command imports the certificate(s)
in the file
<I>jcertfile.cer </I>

and stores it in the
keystore entry identified by the alias 
<B>joe</B>.

<P>

You import a certificate for two reasons:
<DL COMPACT>
<DT>1. <DD>
to add it to the list of trusted
certificates, or
<DT>2. <DD>
to import a certificate reply received
from a CA as the result of submitting a
Certificate Signing Request (see the
<B>-certreq</B>

subcommand) to that CA.
</DL>
<P>

Which type of import is intended is indicated
by the value of the 
<B>-alias</B>

option. If the
alias exists in the database, and identifies
an entry with a private key, then it is
assumed you want to import a certificate
reply. 
<B>keytool</B>

checks whether the public key
in the certificate reply matches the public
key stored with the alias, and exits if they
are different. If the alias identifies the
other type of keystore entry, the certificate
will not be imported. If the alias does not
exist, then it will be created and associated
with the imported certificate.
<P>

<B>
WARNING Regarding Importing Trusted Certificates
<P>

IMPORTANT: Be sure to check a
certificate very carefully before
importing it as a trusted
certificate!
</B>
<P>

View it first (using the 
<B>-printcert</B>

subcommand, or the
<B>-import</B>

subcommand without the
<B>-noprompt</B>

option), and
make sure that the displayed
certificate fingerprint(s) match the
expected ones. For example, suppose
someone sends or emails you a
certificate, and you put it in a
file named 
<B>/tmp/cert</B>.<B>Before</B>you

consider adding the certificate to
your list of trusted certificates,
you can execute a 
<B>-printcert</B>

subcommand
to view its fingerprints, as in
<P>

<B>
</B><PRE>
example% keytool -printcert -file /tmp/cert
Owner: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll
Issuer: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll
Serial Number: 59092b34
Valid from: Thu Sep 25 18:01:13 PDT 1997 until: Wed Dec 24 17:01:13 PST 1997
Certificate Fingerprints:
MD5:  11:81:AD:92:C8:E5:0E:A2:01:2E:D4:7A:D7:5F:07:6F
SHA1: 20:B6:17:FA:EF:E5:55:8A:D0:71:1F:E8:D6:9D:C0:37:13:0E:5E:FE
</PRE>


<P>

Then call or otherwise contact the
person who sent the certificate, and
compare the fingerprint(s) that you
see with the ones that they show.
Only if the fingerprints are equal
is it guaranteed that the
certificate has not been replaced in
transit with somebody else's (for
example, an attacker's) certificate.
If such an attack took place, and
you did not check the certificate
before you imported it, you would
end up trusting anything the
attacker has signed (for example, a
JAR file with malicious class files
inside).
<P>

Note: it is not required that you
execute a 
<B>-printcert</B>

subcommand prior
to importing a certificate, since
before adding a certificate to the
list of trusted certificates in the
keystore, the
<B>-import</B>

subcommand prints
out the certificate information and
prompts you to verify it. You then
have the option of aborting the
import operation. Note, however,
this is only the case if you invoke
the
<B>-import</B>

subcommand without the
<B>-noprompt</B>

option. If the 
<B>-noprompt</B>

option is given, there is no
interaction with the user.
<A NAME="lbAQ">&nbsp;</A>
<H3>Exporting Certificates</H3>

<A NAME="ixAAP"></A>
To export a certificate to a file, use the
<B>-export</B>

subcommand, as in
<P>

<B>
</B><PRE>
example% keytool -export -alias jane -file janecertfile.cer
</PRE>


<P>

This sample command exports jane's certificate
to the file 
<I>janecertfile.cer</I>.

That is, if 
<B>jane</B>

is the alias for a key entry, the command
exports the certificate at the bottom of the
certificate chain in that keystore entry. This
is the certificate that authenticates jane's
public key.
<P>

If, instead, 
<B>jane </B>

is the alias for a trusted
certificate entry, then that trusted
certificate is exported.
<A NAME="lbAR">&nbsp;</A>
<H3>Displaying Certificates</H3>

<A NAME="ixAAQ"></A>
To print out the contents of a keystore entry,
use the
<B>-list</B>

subcommand, as in
<P>

<B>
</B><PRE>
example% keytool -list -alias joe
</PRE>


<P>

If you don't specify an alias, as in
<P>

<B>
</B><PRE>
example% keytool -list
</PRE>


<P>

the contents of the entire keystore are printed.
<P>

To display the contents of a certificate
stored in a file, use the
<B>-printcert</B>

subcommand,
as in
<P>

<B>
</B><PRE>
example% keytool -printcert -file certfile.cer
</PRE>


<P>

This displays information about the
certificate stored in the file 
<I>certfile.cer</I>.

<P>

Note: This works independently of a keystore,
that is, you do not need a keystore in order to
display a certificate that's stored in a file.
<A NAME="lbAS">&nbsp;</A>
<H3>Generating a Self-signed Certificate</H3>

<A NAME="ixAAR"></A>
A self-signed certificate is one for which the
issuer (signer) is the same as the subject
(the entity whose public key is being
authenticated by the certificate). Whenever
the
<B>-genkey</B>

subcommand is called to generate a
new public/private key pair, it also wraps the
public key into a self-signed certificate.
<P>

You may occasionally wish to generate a new
self-signed certificate. For example, you may
want to use the same key pair under a
different identity (distinguished name). For
example, suppose you change departments. You
can then:
<DL COMPACT>
<DT>1. <DD>
copy (clone) the original key entry. See
<B>-keyclone</B>.

<DT>2.<DD>
generate a new self-signed certificate
for the cloned entry, using your new
distinguished name. See below.
<DT>3. <DD>
generate a Certificate Signing Requests
for the cloned entry, and import the
reply certificate or certificate chain.
See the
<B>-certreq</B>

and
<B>-import</B>

subcommand.
<DT>4.<DD>
delete the original (now obsolete) entry.
See
<B>-delete</B>.

</DL>
<P>

To generate a self-signed certificate, use the
<B>-selfcert</B>

subcommand, as in
<P>

<B>
</B><PRE>
example% keytool -selfcert -alias dukeNew -keypass b92kqmp
-dname &quot;cn=Duke Smith, ou=Purchasing, o=BlueSoft, c=US&quot;
</PRE>


<P>

The generated certificate is stored as a
single-element certificate chain in the
keystore entry identified by the specified
alias (in this case <B>dukeNew</B>) where it
replaces the existing certificate chain.
<A NAME="lbAT">&nbsp;</A>
<H2>USAGE</H2>

The various subcommands and their
options are listed and described below.
Note:
<DL COMPACT>
<DT>*<DD>
All subcommand and option names are preceded by a minus sign
(-).
<DT>*<DD>
The options for each subcommand may be provided in any order.
</DL>
<P>

<DL COMPACT>
<DT>*<DD>
All items not italicized or in braces or square brackets are
required to appear as is.
<DT>*<DD>
Braces surrounding an option generally signify that a default
value will be used if the option is not specified on the
command line. Braces are also used around the 
<B>-v</B>,

<B>-rfc</B>,

and
<B>-J</B>

options, which only have meaning if they appear on the
command line (that is, they don't have any &quot;default&quot; values
other than not existing).
<DT>*<DD>
Brackets surrounding an option signify that the user is
prompted for the value(s) if the option is not specified on
the command line. (For a
<B>-keypass</B>

option, if you do not
specify the option on the command line, 
<B>keytool</B>

will first
attempt to use the keystore password to recover the private
key, and if this fails, will then prompt you for the private
key password.)
<DT>*<DD>
Items in italics (option values) represent the actual values
that must be supplied. For example, here is the format of the
<B>-printcert</B>

subcommand:
</DL>
<P>

<B>
</B><PRE>
example% keytool -printcert {-file cert_file} {-v}
</PRE>


<P>

When specifying a
<B>-printcert</B>

subcommand, replace 
<I>cert_file </I>

with
the actual file name, as in:
<P>

<B>
</B><PRE>
example% keytool -printcert -file VScert.cer
</PRE>


<P>

<DL COMPACT>
<DT>*<DD>
Option values must be quoted if they contain a blank (space).
</DL>
<P>

<DL COMPACT>
<DT>*<DD>
The
<B>-help</B>

subcommand is the default. Thus, the command line
</DL>
<P>

<B>
</B><PRE>
example% keytool
</PRE>


<P>

is equivalent to
<P>

<B>
</B><PRE>
example% keytool -help
</PRE>


<A NAME="lbAU">&nbsp;</A>
<H3>Option Defaults</H3>

<A NAME="ixAAS"></A>
Below are the defaults for various option values.
<P>

<B>
</B><PRE>
-alias &quot;mykey&quot;
-keyalg &quot;DSA&quot;
-keysize 1024
-validity 90
-keystore the file named .keystore in the user's home directory
-file stdin if reading, stdout if writing
</PRE>


<P>

The signature algorithm (
<B>-sigalg</B>

option) is derived from
the algorithm of the underlying private key: If the
underlying private key is of type &quot;DSA&quot;, the 
<B>-sigalg</B>

private key is of type &quot;RSA&quot;,
<B>-sigalg</B>

defaults to
&quot;MD5withRSA&quot;.
<A NAME="lbAV">&nbsp;</A>
<H3>Options that Appear for Most Subcommands</H3>

<A NAME="ixAAT"></A>
The
<B>-v</B>

option can appear for all subcommands except 
<B>-help</B>.

If it appears, it signifies &quot;verbose&quot; mode; detailed
certificate information will be output.
<P>

There is also a
<B>-J</B><I>javaoption</I>

option that may appear for
any subcommand.
If it appears, the specified 
<I>-javaoption</I>

string is passed through directly to the Java
interpreter.
(<B>keytool</B>

is actually a &quot;wrapper&quot; around the
interpreter.)  This option should not contain any spaces.
It is useful for adjusting the execution environment or
memory usage.
For a list of possible interpreter options, type
<B>java -h</B>

or
<B>java -X</B>

at the command line.
<P>

There are three options that may appear for all subcommands
operating on a keystore:
<DL COMPACT>
<DT><B>-storetype</B><I> storetype</I>

<DD>
This qualifier specifies the type of keystore to be
instantiated. The default keystore type is the one
that is specified as the value of the
&quot;keystore.type&quot; property in the security properties
file, which is returned by the static
<B>getDefaultType </B>

method in 
<B>java.security.KeyStore</B>.

<DT><B>-keystore</B><I> keystore</I>

<DD>
The keystore (database file) location.
Defaults to
the file 
<B>.keystore </B>

in the user's home directory, as
determined by the 
<B>user.home </B>

system property.
<DT><B>-storepass</B><I> storepass</I>

<DD>
The password which is used to protect the integrity
of the keystore.
<I>storepass </I>

must be at least 6 characters long.
It must be provided to all subcommands that access the
keystore contents.
For such subcommands, if a
<B>-storepass</B>

option is not provided at the command
line, the user is prompted for it.
<DT><B>-provider</B><I> provider_class_name</I>

<DD>
Used to specify the name of the cryptographic service provider's
master class file when the service provider is not listed in
the security properties file.
</DL>
<P>

When retrieving information from the keystore, the
password is optional; if no password is given, the
integrity of the retrieved information cannot be
checked and a warning is displayed.
<P>

Be careful with passwords:
See
<B>Warning Regarding Passwords</B>.

<A NAME="lbAW">&nbsp;</A>
<H3>Warning Regarding Passwords</H3>

<A NAME="ixAAU"></A>
Most subcommands operating on a keystore require the store
password. Some subcommands require a private key password.
<P>

Passwords can be specified on the command line (in the
<B>-storepass</B>

and
<B>-keypass</B>

options, respectively).
However, a password should not be specified on a command line or
in a script unless it is for testing purposes, or you
are on a secure system.
<P>

If you don't specify a required password option on a
command line, you will be prompted for it.
When typing
in a password at the password prompt, the password is
currently echoed (displayed exactly as typed), so be
careful not to type it in front of anyone.
<A NAME="lbAX">&nbsp;</A>
<H3>SUBCOMMANDS</H3>

<A NAME="ixAAV"></A>
See also 
<B>USAGE</B>.

<A NAME="lbAY">&nbsp;</A>
<H3>Adding Data to the Keystore</H3>

<A NAME="ixAAW"></A>
<DL COMPACT>
<DT><B>-genkey {-alias </B><I>alias</I><B>} {-keyalg </B><I>keyalg</I><B>} {-keysize </B><I>keysize}<DD>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</I><B>{-sigalg </B><I>sigalg</I><B>} [-dname </B><I>dname</I><B>] [-keypass </B><I>keypass</I><B>] 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

{-validity </B><I>valDays</I><B>} 

{-storetype </B><I>storetype</I><B>} 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

{-keystore </B><I>keystore</I><B>} [-storepass </B><I>storepass</I><B>]
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[-provider</B><I> provider_class_name</I><B>]</B>

<B>{-v}</B>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<B>{-J</B><I>javaoption</I><B>}
<DL COMPACT><DT><DD>
<P>

Generates a key pair (a public key and associated
private key). Wraps the public key into an X.509 v1
self-signed certificate, which is stored as a
single-element certificate chain. This certificate
chain and the private key are stored in a new
keystore entry identified by 
</B><I>alias</I>.

<P>

keyalg specifies the algorithm to be used to
generate the key pair, and 
<I>keysize </I>

specifies the
size of each key to be generated. 
<I>sigalg </I>

specifies the algorithm that should be used to sign the
self-signed certificate; this algorithm must be
compatible with keyalg. See Supported Algorithms
and Key Sizes.
<P>

<I>dname </I>

specifies the X.500 Distinguished Name to be
associated with 
<I>alias</I>,

and is used as the issuer
and subject fields in the self-signed certificate.
If no distinguished name is provided at the command
line, the user will be prompted for one.
<P>

<I>keypass </I>

is a password used to protect the private
key of the generated key pair. If no password is
provided, the user is prompted for it. If you press
RETURN at the prompt, the key password is set to
the same password as that used for the keystore.
<I>keypass </I>

must be at least 6 characters long. Be
careful with passwords:
See
<B>Warning Regarding Passwords</B>.

<P>

<I>valDays </I>

tells the number of days for which the
certificate should be considered valid.
</DL>

<DT><B>-import {-alias </B><I>alias</I><B>} {-file </B><I>cert_file</I><B>} [-keypass </B><I>keypass</I><B>] <DD>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{-noprompt} {-trustcacerts} {-storetype </B><I>storetype</I><B>} 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

{-keystore </B><I>keystore</I><B>}

[-storepass </B><I>storepass</I><B>]
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

[-provider</B><I> provider_class_name</I><B>]</B>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<B>{-v} {-J</B><I>javaoption</I><B>}</B>

<DL COMPACT><DT><DD>
<P>

Reads the certificate or certificate chain (where
the latter is supplied in a PKCS#7 formatted reply)
from the file 
<I>cert_file</I>,

and stores it in the
keystore entry identified by 
<I>alias</I>


given, the certificate or PKCS#7 reply is read from
stdin. 
<B>keytool</B>

can import X.509 v1, v2, and v3
certificates, and PKCS#7 formatted certificate
chains consisting of certificates of that type. The
data to be imported must be provided either in
binary encoding format, or in printable encoding
format (also known as Base64 encoding) as defined
by the Internet RFC 1421 standard. In the latter
case, the encoding must be bounded at the beginning
by a string that starts with &quot;-----BEGIN&quot;, and
bounded at the end by a string that starts with
&quot;-----END&quot;.
<P>

When importing a new trusted certificate, 
<I>alias</I>

must not yet exist in the keystore. Before adding
the certificate to the keystore, 
<B>keytool</B>

tries to
verify it by attempting to construct a chain of
trust from that certificate to a self-signed
certificate (belonging to a root CA), using trusted
certificates that are already available in the
keystore.
<P>

If the
<B>-trustcacerts</B>

option has been specified,
additional certificates are considered for the
chain of trust, namely the certificates in a file named 
<B>cacerts</B>,

which resides in the JDK security
properties directory, 
<B>java.home/lib/security</B>,

where
<B>java.home </B>

is the JDK installation directory.
The
<B>cacerts </B>

file represents a system-wide keystore
with CA certificates.
System administrators can
configure and manage that file using 
<B>keytool</B>,

specifying &quot;jks&quot; as the keystore type. The
<B>cacerts </B>

keystore file ships with five VeriSign
root CA certificates with the following X.500
distinguished names:
<P>

<DL COMPACT>
<DT>1. <DD>
OU=Class 1 Public Primary Certification Authority, O=&quot;VeriSign, Inc.&quot;,
C=US
<DT>2. <DD>
OU=Class 2 Public Primary Certification Authority, O=&quot;VeriSign,
Inc.&quot;, C=US
<DT>3. <DD>
OU=Class 3 Public Primary Certification Authority,
O=&quot;VeriSign, Inc.&quot;, C=US
<DT>4.<DD>
OU=Class 4 Public Primary Certification
Authority, O=&quot;VeriSign, Inc.&quot;, C=US
<DT>5.<DD>
OU=Secure Server Certification
Authority, O=&quot;RSA Data Security, Inc.&quot;, C=US
</DL>
<P>

The initial password of the 
<B>cacerts</B>

keystore file is &quot;changeit&quot;.
System administrators should change
that password and the default access permission of
that file upon installing the JDK.
<P>

If 
<B>keytool</B>

fails to establish a trust path from the
certificate to be imported up to a self-signed
certificate (either from the keystore or the
<B>cacerts</B>

file), the certificate information is
printed out, and the user is prompted to verify it,
for example, by comparing the displayed certificate
fingerprints with the fingerprints obtained from
some other (trusted) source of information, which
might be the certificate owner himself/herself. Be
very careful to ensure the certificate is valid
prior to importing it as a &quot;trusted&quot; certificate!
-- see WARNING Re: Importing Trusted Certificates.
The user then has the option of aborting the import
operation. If the
<B>-noprompt</B>

option is given,
however, there will be no interaction with the
user.
<P>

When importing a certificate reply, the certificate
reply is validated using trusted certificates from
the keystore, and optionally using the certificates
configured in the 
<B>cacerts</B>

keystore file (if the
<B>-trustcacerts</B>

option was specified).
<P>

If the reply is a single X.509 certificate, 
<B>keytool</B>

attempts to establish a trust chain, starting at
the certificate reply and ending at a self-signed
certificate (belonging to a root CA). The
certificate reply and the hierarchy of certificates
used to authenticate the certificate reply form the
new certificate chain of 
<I>alias</I>.

<P>

If the reply is a PKCS#7 formatted certificate
chain, the chain is first ordered (with the user
certificate first and the self-signed root CA
certificate last), before 
<B>keytool</B>

attempts to match
the root CA certificate provided in the reply with
any of the trusted certificates in the keystore or
the 
<B>cacerts</B>

keystore file (if the
<B>-trustcacerts</B>

option was specified). If no match can be found,
the information of the root CA certificate is
printed out, and the user is prompted to verify it,
for example, by comparing the displayed certificate
fingerprints with the fingerprints obtained from
some other (trusted) source of information, which
might be the root CA itself. The user then has the
option of aborting the import operation. If the
-noprompt option is given, however, there will be
no interaction with the user.
<P>

The new certificate chain of 
<I>alias </I>

replaces the old
certificate chain associated with this entry. The
old chain can only be replaced if a valid keypass,
the password used to protect the private key of the
entry, is supplied. If no password is provided, and
the private key password is different from the
keystore password, the user is prompted for it.
Be careful with passwords:
See
<B>Warning Regarding Passwords</B>.

</DL>

<DT><B>-selfcert {-alias </B><I>alias</I><B>} {-sigalg </B><I>sigalg</I><B>} {-dname </B><I>dname</I><B>}<DD>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{-validity </B><I>valDays</I><B>}
[-keypass </B><I>keypass</I><B>] 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

{-storetype </B><I>storetype</I><B>}

{-keystore </B><I>keystore</I><B>}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

[-storepass </B><I>storepass</I><B>]
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

[-provider</B><I> provider_class_name</I><B>]</B>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{-v} {-J<I>javaoption</I><B>}
<DL COMPACT><DT><DD>
<P>

Generates an X.509 v1 self-signed certificate,
using keystore information including the private
key and public key associated with 
</B><I>alias</I>.

If 
<I>dname</I>

is supplied at the command line, it is used as the
X.500 Distinguished Name for both the issuer and
subject of the certificate. Otherwise, the X.500
Distinguished Name associated with 
<I>alias </I>

(at the
bottom of its existing certificate chain) is used.
<P>

The generated certificate is stored as a
single-element certificate chain in the keystore
entry identified by 
<I>alias</I>,

where it replaces the
existing certificate chain.
<P>

<I>sigalg </I>

specifies the algorithm that should be used
to sign the certificate. See Supported Algorithms
and Key Sizes.
<P>

In order to access the private key, the appropriate
password must be provided, since private keys are
protected in the keystore with a password. If
<I>keypass </I>

is not provided at the command line, and is
different from the password used to protect the
integrity of the keystore, the user is prompted for
it.
Be careful with passwords:
See
<B>Warning Regarding Passwords</B>.

<P>

<I>valDays </I>

tells the number of days for which the
certificate should be considered valid.
</DL>


<BR>

<DT>
<DD>
<B>-identitydb {-file </B><I>idb_file</I><B>} {-storetype </B><I>storetype</I><B>}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{-keystore </B><I>keystore</I><B>}
[-storepass </B><I>storepass</I><B>] 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

[-provider</B><I> provider_class_name</I><B>]</B>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<B>{-v} {-J</B><I>javaoption</I><B>}
<DL COMPACT><DT><DD>
<P>

Reads the JDK 1.1.x-style identity database from
the file 
</B><I>idb_file</I>,

and adds its entries to the
keystore. If no file is given, the identity
database is read from stdin. If a keystore does not
exist, it is created.
<P>

Only identity database entries (&quot;identities&quot;) that
were marked as trusted will be imported in the
keystore. All other identities will be ignored. For
each trusted identity, a keystore entry will be
created. The identity's name is used as the 
<I>alias </I>

for the keystore entry.
<P>

The private keys from trusted identities will all
be encrypted under the same password, storepass.
This is the same password that is used to protect
the keystore's integrity. Users can later assign
individual passwords to those private keys by using
the 
<B>-keypasswd </B>

<B>keytool</B>

command option.
<P>

An identity in an identity database may hold more
than one certificate, each certifying the same
public key. But a keystore key entry for a private
key has that private key and a single &quot;certificate
chain&quot; (initially just a single certificate), where
the first certificate in the chain contains the
public key corresponding to the private key. When
importing the information from an identity, only
the first certificate of the identity is stored in
the keystore. This is because an identity's name in
an identity database is used as the 
<I>alias </I>

for its
corresponding keystore entry, and 
<I>alias </I>

names are
unique within a keystore,
</DL>

</DL>
<A NAME="lbAZ">&nbsp;</A>
<H3>Exporting Data</H3>

<A NAME="ixAAX"></A>
<DL COMPACT>
<DT>
<DD>
<B>-certreq {-alias </B><I>alias</I><B>} {-sigalg </B><I>sigalg</I><B>} {-file </B><I>certreq_file</I><B>}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

[-keypass </B><I>keypass</I><B>] 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{-storetype </B><I>storetype</I><B>} {-keystore </B><I>keystore</I><B>} 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

[-storepass </B><I>storepass</I><B>]
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[-provider</B><I> provider_class_name</I><B>]</B>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<B>{-v} {-J</B><I>javaoption</I><B>}
<DL COMPACT><DT><DD>
<P>

Generates a Certificate Signing Request (CSR),
using the PKCS#10 format.
<P>

A CSR is intended to be sent to a certificate
authority (CA). The CA will authenticate the
certificate requestor (usually off-line) and will
return a certificate or certificate chain, used to
replace the existing certificate chain (which
initially consists of a self-signed certificate) in
the keystore.
<P>

The private key and X.500 Distinguished Name
associated with 
</B><I>alias </I>

are used to create the
PKCS#10 certificate request. In order to access the
private key, the appropriate password must be
provided, since private keys are protected in the
keystore with a password. If 
<I>keypass </I>

is not
provided at the command line, and is different from
the password used to protect the integrity of the
keystore, the user is prompted for it.
<P>

Be careful with passwords:
See
<B>Warning Regarding Passwords</B>.

<P>

<I>sigalg </I>

specifies the algorithm that should be used
to sign the CSR. See Supported Algorithms and Key
Sizes.
<P>

The CSR is stored in the file 
<I>certreq_file</I>.

If no
file is given, the CSR is output to stdout.
<P>

Use the import command to import the response from
the CA.
</DL>

<DT>
<DD>
<B>-export {-alias </B><I>alias</I><B>} {-file </B><I>cert_file</I><B>} {-storetype </B><I>storetype</I><B>}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

{-keystore </B><I>keystore</I><B>} 

[-storepass </B><I>storepass</I><B>]
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

[-provider</B><I> provider_class_name</I><B>]</B>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<B>{-rfc} {-v} {-J</B><I>javaoption</I><B>}
<DL COMPACT><DT><DD>
<P>

Reads (from the keystore) the certificate
associated with 
</B><I>alias</I>,

and stores it in the file
<I>cert_file</I>.

<P>

If no file is given, the certificate is output to
<B>stdout</B>.

<P>

The certificate is by default output in binary
encoding, but will instead be output in the
printable encoding format, as defined by the
Internet RFC 1421 standard, if the
<B>-rfc</B>

option is
specified.
<P>

If 
<I>alias </I>

refers to a trusted certificate, that
certificate is output. Otherwise, 
<I>alias </I>

refers to a
key entry with an associated certificate chain. In
that case, the first certificate in the chain is
returned. This certificate authenticates the public
key of the entity addressed by 
<I>alias</I>.

</DL>
</DL>
<A NAME="lbBA">&nbsp;</A>
<H3>Displaying Data</H3>

<A NAME="ixAAY"></A>
<DL COMPACT>
<DT>
<DD>
<B>-list {-alias </B><I>alias</I><B>} {-storetype </B><I>storetype</I><B>} {-keystore </B><I>keystore}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[-storepass storepass</I><B>] 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

[-provider</B><I> provider_class_name</I><B>]</B>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<B>{-v | -rfc} {-J</B><I>javaoption</I><B>}
<DL COMPACT><DT><DD>
<P>

Prints (to stdout) the contents of the keystore
entry identified by 
</B><I>alias</I>.

If no 
<I>alias </I>

is specified, the contents of the entire keystore are printed.
<P>

This subcommand by default prints the MD5 fingerprint
of a certificate.
If the
<B>-v</B>

option is specified,
the certificate is printed in human-readable
format, with additional information such as
the owner, issuer, and serial number.
If the
<B>-rfc</B>

option is specified,
certificate contents are printed using the
printable encoding format, as defined by the
Internet RFC 1421 standard
<P>

You cannot specify both
<B>-v</B>

and
<B>-rfc</B>.

</DL>

<DT><B>-printcert {-file </B><I>cert_file</I><B>} {-v} {-J</B><I>javaoption</I><B>}<DD>
<DL COMPACT><DT><DD>
<P>

Reads the certificate from the file 
</B><I>cert_file</I>,

and
prints its contents in a human-readable format. If
no file is given, the certificate is read from
stdin.
<P>

The certificate may be either binary encoded or in
printable encoding format, as defined by the
Internet RFC 1421 standard.
<P>

Note: This option can be used independently of a
keystore.
</DL>

</DL>
<A NAME="lbBB">&nbsp;</A>
<H3>Managing the Keystore</H3>

<A NAME="ixAAZ"></A>
<DL COMPACT>
<DT>
<DD>
<B>-keyclone {-alias </B><I>alias</I><B>} [-dest </B><I>dest_alias</I><B>] [-keypass </B><I>keypass</I><B>]
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

{-new </B><I>new_keypass</I><B>} 

{-storetype </B><I>storetype</I><B>}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

{-keystore </B><I>keystore</I><B>} 
[-storepass </B><I>storepass</I><B>]
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[-provider</B><I> provider_class_name</I><B>]</B>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<B>{-v} {-J</B><I>javaoption</I><B>}
<DL COMPACT><DT><DD>
<P>

Creates a new keystore entry, which has the same
private key and certificate chain as the original
entry.
<P>

The original entry is identified by 
</B><I>alias </I>

(which
defaults to 
&quot;mykey&quot; if not provided). The new
(destination) entry is identified by 
<I>dest_alias</I>.

If no destination 
<I>alias </I>

is supplied at the command
line, the user is prompted for it.
<P>

If the private key password is different from the
keystore password, then the entry will only be
cloned if a valid 
<I>keypass </I>

is supplied.
This is the
password used to protect the private key associated with 
<I>alias</I>.

If no key password is supplied at the
command line, and the private key password is
different from the keystore password, the user is
prompted for it.
The private key in the cloned
entry may be protected with a different password,
if desired. If no
<B>-new</B>

option is supplied at the
command line, the user is prompted for the new
entry's password (and may choose to let it be the
same as for the cloned entry's private key).
<P>

Be careful with passwords:
See
<B>Warning Regarding Passwords</B>.

<P>

This subcommand can be used to establish multiple
certificate chains corresponding to a given key
pair, or for backup purposes.
</DL>

<DT><B>-storepasswd {-new </B><I>new_storepass</I><B>} {-storetype </B><I>storetype</I><B>}<DD>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{-keystore </B><I>keystore</I><B>} [-storepass </B><I>storepass</I><B>]
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

[-provider</B><I> provider_class_name</I><B>]</B>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<B>{-v} {-J</B><I>javaoption</I><B>}
<DL COMPACT><DT><DD>
<P>

Changes the password used to protect the integrity
of the keystore contents. The new password is
</B><I>new_storepass</I>,

which must be at least 6 characters long.
<P>

Be careful with passwords:
<B>Warning Regarding Passwords</B>.

</DL>

<DT><B>-keypasswd {-alias </B><I>alias</I><B>} [-keypass </B><I>old_keypass</I><B>] <DD>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[-new </B><I>new_keypass</I><B>] {-storetype </B><I>storetype</I><B>} 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

{-keystore </B><I>keystore</I><B>}

[-storepass </B><I>storepass</I><B>] 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

[-provider</B><I> provider_class_name</I><B>]</B>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<B>{-v} {-J</B><I>javaoption</I><B>}
<DL COMPACT><DT><DD>
<P>

Changes the password under which the private key
identified by 
</B><I>alias </I>

is protected, from 
<I>old_keypass</I>

to 
<I>new_keypass</I>.

<P>

If the
<B>-keypass</B>

option is not provided at the
command line, and the private key password is
different from the keystore password, the user is
prompted for it.
<P>

If the
<B>-new</B>

option is not provided at the command
line, the user is prompted for it.
<P>

Be careful with passwords:
See
<B> Warning Regarding Passwords</B>.

</DL>

<DT><B>-delete [-alias </B><I>alias</I><B>] {-storetype </B><I>storetype</I><B>} <DD>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{-keystore </B><I>keystore</I><B>} [-storepass </B><I>storepass</I><B>]
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

[-provider</B><I> provider_class_name</I><B>]</B>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<B>{-v} {-J</B><I>javaoption</I><B>}
<DL COMPACT><DT><DD>
<P>

Deletes from the keystore the entry identified by
</B><I>alias</I>.

The user is prompted for the 
<I>alias</I>,

if no
<I>alias </I>

is provided at the command line.
</DL>

</DL>
<A NAME="lbBC">&nbsp;</A>
<H3>Getting Help</H3>

<A NAME="ixABA"></A>
<DL COMPACT>
<DT><B>-help</B>

<DD>
</DL>
<A NAME="lbBD">&nbsp;</A>
<H2>EXAMPLES</H2>

Suppose you want to create a keystore for managing your
public/private key pair and certificates from entities you trust.
<A NAME="lbBE">&nbsp;</A>
<H3>Generating Your Key Pair</H3>

<A NAME="ixABB"></A>
The first thing you need to do is create a keystore and
generate the key pair. You could use a command such as
the following:
<P>

<B>
</B><PRE>
example% keytool -genkey -dname &quot;cn=Mark Jones, ou=Java, o=Sun, c=US&quot;
-alias business -keypass kpi135 -keystore /working/mykeystore
-storepass ab987c -validity 180
</PRE>


<P>

(Please note: This must be typed as a single line.
Multiple lines are used in the examples just for
legibility purposes.)
<P>

This command creates the keystore named 
<B>mykeystore</B>

in the 
<B>working</B>

directory (assuming it does not already
exist), and assigns it the password 
<B>ab987c</B>.

It
generates a public/private key pair for the entity whose
&quot;distinguished name&quot; has a common name of 
<B>Mark</B>Jones<B>,</B>

organizational unit of 
<B>Java</B>,

organization of 
<B>Sun</B>

and two-letter country code of 
<B>US</B>.

It uses the default
&quot;DSA&quot; key generation algorithm to create the keys, both
1024 bits long.
<P>

It creates a self-signed certificate (using the default
&quot;SHA1withDSA&quot; signature algorithm) that includes the
public key and the distinguished name information. This
certificate will be valid for 
<B>180 </B>

days, and is
associated with the private key in a keystore entry
referred to by the alias 
<B>business</B>.

The private key is
assigned the password 
<B>kpi135</B>.

<P>

The command could be significantly shorter if option
defaults were accepted. As a matter of fact, no options
are required; defaults are used for unspecified options
that have default values, and you are prompted for any
required values. Thus, you could simply have the
following:
<P>

<B>
</B><PRE>
example% keytool -genkey
</PRE>


<P>

In this case, a keystore entry with alias 
<B>mykey  </B>

is
created, with a newly-generated key pair and a
certificate that is valid for 90 days. This entry is
placed in the keystore named 
<B>.keystore</B>

in your home
directory. (The keystore is created if it doesn't
already exist.) You will be prompted for the
distinguished name information, the keystore password,
and the private key password.
<P>

The rest of the examples assume you executed the
<B>-genkey</B>

command without options specified, and that you
responded to the prompts with values equal to those
given in the first
<B>-genkey</B>

command, above (a private key
password of 
<B>kpi135</B>,

and so forth.)
<A NAME="lbBF">&nbsp;</A>
<H3>Requesting a Signed Certificate from a Certification Authority</H3>

<A NAME="ixABC"></A>
So far all we've got is a self-signed certificate. A
certificate is more likely to be trusted by others if it
is signed by a Certification Authority (CA). To get such
a signature, you first generate a Certificate Signing
Request (CSR), via the following:
<P>

<B>
</B><PRE>
example% keytool -certreq -file MarkJ.csr
</PRE>


<P>

This creates a CSR (for the entity identified by the
default alias <B>mykey</B> and puts the request in the file
named 
<B>MarkJ.csr</B>.

Submit this file to a CA, such as
VeriSign, Inc. The CA will authenticate you, the
requestor (usually off-line), and then will return a
certificate, signed by them, authenticating your public
key. (In some cases, they will actually return a chain
of certificates, each one authenticating the public key
of the signer of the previous certificate in the chain.)
<A NAME="lbBG">&nbsp;</A>
<H3>Importing a Certificate for the CA</H3>

<A NAME="ixABD"></A>
You need to replace your self-signed certificate with a
certificate chain, where each certificate in the chain
authenticates the public key of the signer of the
previous certificate in the chain, up to a &quot;root&quot; CA.
<P>

Before you import the certificate reply from a CA, you
need one or more &quot;trusted certificates&quot; in your keystore
or in the cacerts keystore file (which is described in
<B>import</B>command<B>):</B>

<DL COMPACT>
<DT>*<DD>
If the certificate reply is a certificate chain,
you just need the top certificate of the chain
(that is, the &quot;root&quot; CA certificate authenticating
that CA's public key).
<DT>*<DD>
If the certificate reply is a single certificate,
you need a certificate for the issuing CA (the one
that signed it), and if that certificate is not
self-signed, you need a certificate for its signer,
and so on, up to a self-signed &quot;root&quot; CA
certificate.
</DL>
<P>

The 
<B>cacerts </B>

keystore file ships with five VeriSign
root CA certificates, so you probably won't need to
import a VeriSign certificate as a trusted certificate
in your keystore. But if you request a signed
certificate from a different CA, and a certificate
authenticating that CA's public key hasn't been added to
<B>cacerts</B>,

you will need to import a certificate from
the CA as a &quot;trusted certificate&quot;.
<P>

A certificate from a CA is usually either self-signed,
or signed by another CA (in which case you also need a
certificate authenticating that CA's public key).
Suppose company ABC, Inc., is a CA, and you obtain a
file named 
<B>ABCCA.cer</B>

that is purportedly a self-signed
certificate from ABC, authenticating that CA's public
key.
<P>

Be very careful to ensure the certificate is valid prior
to importing it as a &quot;trusted&quot; certificate! View it
first (using the 
<B>-printcert </B>

subcommand, or the
<B>-import </B>

subcommand without the 
<B>-noprompt</B>

option),
and make sure that the displayed certificate
fingerprint(s) match the expected ones. You can call the
person who sent the certificate, and compare the
fingerprint(s) that you see with the ones that they show
(or that a secure public key repository shows). Only if
the fingerprints are equal is it guaranteed that the
certificate has not been replaced in transit with
somebody else's (for example, an attacker's)
certificate. If such an attack took place, and you did
not check the certificate before you imported it, you
would end up trusting anything the attacker has signed.
<P>

If you trust that the certificate is valid, then you can
add it to your keystore via the following:
<P>

<B>
</B><PRE>
example% keytool -import -alias abc -file ABCCA.cer
</PRE>


<P>

This creates a &quot;trusted certificate&quot; entry in the
keystore, with the data from the file 
<B>ABCCA.cer</B>,

and assigns the alias 
<B>abc  </B>

to the entry.
<A NAME="lbBH">&nbsp;</A>
<H3>Importing the Certificate Reply from the CA</H3>

<A NAME="ixABE"></A>
Once you've imported a certificate authenticating the
public key of the CA you submitted your certificate
signing request to (or there's already such a
certificate in the 
<B>cacerts</B>

file), you can import the
certificate reply and thereby replace your self-signed
certificate with a certificate chain. This chain is the
one returned by the CA in response to your request (if
the CA reply is a chain), or one constructed (if the CA
reply is a single certificate) using the certificate
reply and trusted certificates that are already
available in the keystore where you import the reply or
in the 
<B>cacerts</B>

keystore file.
<P>

For example, suppose you sent your certificate signing
request to VeriSign. You can then import the reply via
the following, which assumes the returned certificate is
named 
<B>VSMarkJ.cer</B>:

<P>

<B>
</B><PRE>
example% keytool -import -trustcacerts -file VSMarkJ.cer
</PRE>


<A NAME="lbBI">&nbsp;</A>
<H3>Exporting a Certificate Authenticating Your Public Key</H3>

<A NAME="ixABF"></A>
Suppose you have used the 
<B><A HREF="../man1/jarsigner.1.php">jarsigner</A></B>(1)

tool to sign a Java
ARchive (JAR) file. Clients that want to use the file
will want to authenticate your signature.
<P>

One way they can do this is by first importing your
public key certificate into their keystore as a
&quot;trusted&quot; entry. You can export the certificate and
supply it to your clients. As an example, you can copy
your certificate to a file named 
<B>MJ.cer </B>

via the
following, assuming the entry is aliased by 
<B>mykey</B>:

<P>

<B>
</B><PRE>
example% keytool -export -alias mykey -file MJ.cer
</PRE>


<P>

Given that certificate, and the signed JAR file, a
client can use the 
<B><A HREF="../man1/jarsigner.1.php">jarsigner</A></B>(1)

tool to authenticate your
signature.
<A NAME="lbBJ">&nbsp;</A>
<H3>Changing Your Distinguished Name but Keeping your Key Pair</H3>

<A NAME="ixABG"></A>
Suppose your distinguished name changes, for example
because you have changed departments or moved to a
different city. If desired, you may still use the
public/private key pair you've previously used, and yet
update your distinguished name. For example, suppose
your name is Susan Miller, and you created your initial
key entry with the alias 
<B>sMiller </B>

and the distinguished
name
<P>

<B>
</B><PRE>
&quot;cn=Susan Miller, ou=Finance Department, o=BlueSoft, c=us&quot;
</PRE>


<P>

Suppose you change from the Finance Department to the
Accounting Department. You can still use the
previously-generated public/private key pair and yet
update your distinguished name by doing the following.
First, copy (clone) your key entry:
<P>

<B>
</B><PRE>
example% keytool -keyclone -alias sMiller -dest sMillerNew
</PRE>


<P>

(This prompts for the store password and for 
the initial and destination private
key passwords, since they aren't provided at the command
line.) Now you need to change the certificate chain
associated with the copy, so that the first certificate
in the chain uses your different distinguished name.
Start by generating a self-signed certificate with the
appropriate name:
<P>

<B>
</B><PRE>
example% keytool -selfcert -alias sMillerNew
-dname &quot;cn=Susan Miller, ou=Accounting Department, o=BlueSoft, c=us&quot;
</PRE>


<P>

Then generate a Certificate Signing Request based on the
information in this new certificate:
<P>

<B>
</B><PRE>
example% keytool -certreq -alias sMillerNew
</PRE>


<P>

When you get the CA certificate reply, import it:
<P>

<B>
</B><PRE>
example% keytool -import -alias sMillerNew -file VSSMillerNew.cer
</PRE>


<P>

After importing the certificate reply, you may want to
remove the initial key entry that used your old
distinguished name:
<P>

<B>
</B><PRE>
example% keytool -delete -alias sMiller
</PRE>


<BR>


<A NAME="lbBK">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="../man1/jar.1.php">jar</A></B>(1),

<B><A HREF="../man1/jarsigner.1.php">jarsigner</A></B>(1)

<P>

See (or search
<B>java.sun.com</B>)

for the following:
<DL COMPACT>
<DT><B>Security in the Java 2 Platform @</B>

<DD>
<A HREF="http://java.sun.com/docs/books/tutorial/security1.2/index.php">http://java.sun.com/docs/books/tutorial/security1.2/index.html</A>
<P>
</DL>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAE">Keystore Entries</A><DD>
<DT><A HREF="#lbAF">Keystore Aliases</A><DD>
<DT><A HREF="#lbAG">Keystore Location</A><DD>
<DT><A HREF="#lbAH">Keystore Creation</A><DD>
<DT><A HREF="#lbAI">Keystore Implementation</A><DD>
<DT><A HREF="#lbAJ">Supported Algorithms and Key Sizes</A><DD>
<DT><A HREF="#lbAK">Certificates</A><DD>
<DT><A HREF="#lbAL">X.509 Certificates</A><DD>
<DT><A HREF="#lbAM">X.500 Distinguished Names</A><DD>
<DT><A HREF="#lbAN">The Internet RFC 1421 Certificate Encoding Standard</A><DD>
<DT><A HREF="#lbAO">Certificate Chains</A><DD>
<DT><A HREF="#lbAP">Importing Certificates</A><DD>
<DT><A HREF="#lbAQ">Exporting Certificates</A><DD>
<DT><A HREF="#lbAR">Displaying Certificates</A><DD>
<DT><A HREF="#lbAS">Generating a Self-signed Certificate</A><DD>
</DL>
<DT><A HREF="#lbAT">USAGE</A><DD>
<DL>
<DT><A HREF="#lbAU">Option Defaults</A><DD>
<DT><A HREF="#lbAV">Options that Appear for Most Subcommands</A><DD>
<DT><A HREF="#lbAW">Warning Regarding Passwords</A><DD>
<DT><A HREF="#lbAX">SUBCOMMANDS</A><DD>
<DT><A HREF="#lbAY">Adding Data to the Keystore</A><DD>
<DT><A HREF="#lbAZ">Exporting Data</A><DD>
<DT><A HREF="#lbBA">Displaying Data</A><DD>
<DT><A HREF="#lbBB">Managing the Keystore</A><DD>
<DT><A HREF="#lbBC">Getting Help</A><DD>
</DL>
<DT><A HREF="#lbBD">EXAMPLES</A><DD>
<DL>
<DT><A HREF="#lbBE">Generating Your Key Pair</A><DD>
<DT><A HREF="#lbBF">Requesting a Signed Certificate from a Certification Authority</A><DD>
<DT><A HREF="#lbBG">Importing a Certificate for the CA</A><DD>
<DT><A HREF="#lbBH">Importing the Certificate Reply from the CA</A><DD>
<DT><A HREF="#lbBI">Exporting a Certificate Authenticating Your Public Key</A><DD>
<DT><A HREF="#lbBJ">Changing Your Distinguished Name but Keeping your Key Pair</A><DD>
</DL>
<DT><A HREF="#lbBK">SEE ALSO</A><DD>
</DL>

</div>






</div>




</body>
</html>
