
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<title>PERLFAQ9</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="/global/main.css" title="default">
</head>

<body>



<div id="container">


<div id="content">

<div id='catHeader'><table width='100%'><tr><td>
<H1>PERLFAQ9</H1>
Section: Perl Programmers Reference Guide (1)<BR>Updated: 2004-04-23<BR>
</td><td align='right' valign='bottom'><div class='ad_header_right'></div></td></tr></table></div></div>
<div id='categories'>
<div class='ad_man_right'>
</div>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

perlfaq9 - Networking ($Revision: 1.15 $, $Date: 2003/01/31 17:36:57 $)
<A NAME="lbAC">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAC"></A>
This section deals with questions related to networking, the internet,
and a few on the web.
<A NAME="lbAD">&nbsp;</A>
<H2>What is the correct form of response from a <FONT SIZE="-1">CGI</FONT> script?</H2>

<A NAME="ixAAD"></A>
(Alan Flavell &lt;<A HREF="mailto:flavell+www@a5.ph.gla.ac.uk">flavell+www@a5.ph.gla.ac.uk</A>&gt; answers...)
<P>

The Common Gateway Interface (<FONT SIZE="-1">CGI</FONT>) specifies a software interface between
a program (``<FONT SIZE="-1">CGI</FONT> script'') and a web server (<FONT SIZE="-1">HTTPD</FONT>). It is not specific
to Perl, and has its own FAQs and tutorials, and usenet group,
comp.infosystems.<A HREF="http://www.authoring.cgi">www.authoring.cgi</A>
<P>

The original <FONT SIZE="-1">CGI</FONT> specification is at: <A HREF="http://hoohoo.ncsa.uiuc.edu/cgi/">http://hoohoo.ncsa.uiuc.edu/cgi/</A>
<P>

Current best-practice <FONT SIZE="-1">RFC</FONT> draft at: <A HREF="http://CGI-Spec.Golux.Com/">http://CGI-Spec.Golux.Com/</A>
<P>

Other relevant documentation listed in: <A HREF="http://www.perl.org/CGI_MetaFAQ.php">http://www.perl.org/CGI_MetaFAQ.html</A>
<P>

These Perl FAQs very selectively cover some <FONT SIZE="-1">CGI</FONT> issues. However, Perl
programmers are strongly advised to use the <FONT SIZE="-1">CGI</FONT>.pm module, to take care
of the details for them.
<P>

The similarity between <FONT SIZE="-1">CGI</FONT> response headers (defined in the <FONT SIZE="-1">CGI</FONT>
specification) and <FONT SIZE="-1">HTTP</FONT> response headers (defined in the <FONT SIZE="-1">HTTP</FONT>
specification, <FONT SIZE="-1">RFC2616</FONT>) is intentional, but can sometimes be confusing.
<P>

The <FONT SIZE="-1">CGI</FONT> specification defines two kinds of script: the ``Parsed Header''
script, and the ``Non Parsed Header'' (<FONT SIZE="-1">NPH</FONT>) script. Check your server
documentation to see what it supports. ``Parsed Header'' scripts are
simpler in various respects. The <FONT SIZE="-1">CGI</FONT> specification allows any of the
usual newline representations in the <FONT SIZE="-1">CGI</FONT> response (it's the server's
job to create an accurate <FONT SIZE="-1">HTTP</FONT> response based on it). So ``\n'' written in
text mode is technically correct, and recommended. <FONT SIZE="-1">NPH</FONT> scripts are more
tricky: they must put out a complete and accurate set of <FONT SIZE="-1">HTTP</FONT>
transaction response headers; the <FONT SIZE="-1">HTTP</FONT> specification calls for records
to be terminated with carriage-return and line-feed, i.e <FONT SIZE="-1">ASCII</FONT> \015\012
written in binary mode.
<P>

Using <FONT SIZE="-1">CGI</FONT>.pm gives excellent platform independence, including <FONT SIZE="-1">EBCDIC</FONT>
systems. <FONT SIZE="-1">CGI</FONT>.pm selects an appropriate newline representation
($CGI::CRLF) and sets binmode as appropriate.
<A NAME="lbAE">&nbsp;</A>
<H2>My <FONT SIZE="-1">CGI</FONT> script runs from the command line but not the browser.  (500 Server Error)

</H2>

<A NAME="ixAAE"></A>
Several things could be wrong.  You can go through the ``Troubleshooting
Perl <FONT SIZE="-1">CGI</FONT> scripts'' guide at
<P>



<PRE>
        <A HREF="http://www.perl.org/troubleshooting_CGI.php">http://www.perl.org/troubleshooting_CGI.html</A>

</PRE>


<P>

If, after that, you can demonstrate that you've read the FAQs and that
your problem isn't something simple that can be easily answered, you'll
probably receive a courteous and useful reply to your question if you
post it on comp.infosystems.<A HREF="http://www.authoring.cgi">www.authoring.cgi</A> (if it's something to do
with <FONT SIZE="-1">HTTP</FONT> or the <FONT SIZE="-1">CGI</FONT> protocols).  Questions that appear to be Perl
questions but are really <FONT SIZE="-1">CGI</FONT> ones that are posted to comp.lang.perl.misc
are not so well received.
<P>

The useful FAQs, related documents, and troubleshooting guides are
listed in the <FONT SIZE="-1">CGI</FONT> Meta <FONT SIZE="-1">FAQ:</FONT>
<P>



<PRE>
        <A HREF="http://www.perl.org/CGI_MetaFAQ.php">http://www.perl.org/CGI_MetaFAQ.html</A>

</PRE>


<A NAME="lbAF">&nbsp;</A>
<H2>How can I get better error messages from a <FONT SIZE="-1">CGI</FONT> program?</H2>

<A NAME="ixAAF"></A>
Use the CGI::Carp module.  It replaces <TT>&quot;warn&quot;</TT> and <TT>&quot;die&quot;</TT>, plus the
normal Carp modules <TT>&quot;carp&quot;</TT>, <TT>&quot;croak&quot;</TT>, and <TT>&quot;confess&quot;</TT> functions with
more verbose and safer versions.  It still sends them to the normal
server error log.
<P>



<PRE>
    use CGI::Carp;
    warn &quot;This is a complaint&quot;;
    die &quot;But this one is serious&quot;;

</PRE>


<P>

The following use of CGI::Carp also redirects errors to a file of your choice,
placed in a <FONT SIZE="-1">BEGIN</FONT> block to catch compile-time warnings as well:
<P>



<PRE>
    BEGIN {
        use CGI::Carp qw(carpout);
        open(LOG, &quot;&gt;&gt;/var/local/cgi-logs/mycgi-log&quot;)
            or die &quot;Unable to append to mycgi-log: $!\n&quot;;
        carpout(*LOG);
    }

</PRE>


<P>

You can even arrange for fatal errors to go back to the client browser,
which is nice for your own debugging, but might confuse the end user.
<P>



<PRE>
    use CGI::Carp qw(fatalsToBrowser);
    die &quot;Bad error here&quot;;

</PRE>


<P>

Even if the error happens before you get the <FONT SIZE="-1">HTTP</FONT> header out, the module
will try to take care of this to avoid the dreaded server 500 errors.
Normal warnings still go out to the server error log (or wherever
you've sent them with <TT>&quot;carpout&quot;</TT>) with the application name and date
stamp prepended.
<A NAME="lbAG">&nbsp;</A>
<H2>How do I remove <FONT SIZE="-1">HTML</FONT> from a string?</H2>

<A NAME="ixAAG"></A>
The most correct way (albeit not the fastest) is to use HTML::Parser
from <FONT SIZE="-1">CPAN</FONT>.  Another mostly correct
way is to use HTML::FormatText which not only removes <FONT SIZE="-1">HTML</FONT> but also
attempts to do a little simple formatting of the resulting plain text.
<P>

Many folks attempt a simple-minded regular expression approach, like
<TT>&quot;s/&lt;.*?&gt;//g&quot;</TT>, but that fails in many cases because the tags
may continue over line breaks, they may contain quoted angle-brackets,
or <FONT SIZE="-1">HTML</FONT> comment may be present.  Plus, folks forget to convert
entities---like <TT>&quot;&amp;lt;&quot;</TT> for example.
<P>

Here's one ``simple-minded'' approach, that works for most files:
<P>



<PRE>
    #!/usr/bin/perl -p0777
    s/&lt;(?:[^&gt;'&quot;]*|(['&quot;]).*?\1)*&gt;//gs

</PRE>


<P>

If you want a more complete solution, see the 3-stage striphtml
program in
<A HREF="http://www.cpan.org/authors/Tom_Christiansen/scripts/striphtml.gz">http://www.cpan.org/authors/Tom_Christiansen/scripts/striphtml.gz</A>
.
<P>

Here are some tricky cases that you should think about when picking
a solution:
<P>



<PRE>
    &lt;IMG SRC = &quot;foo.gif&quot; ALT = &quot;A &gt; B&quot;&gt;

</PRE>


<P>



<PRE>
    &lt;IMG SRC = &quot;foo.gif&quot;
         ALT = &quot;A &gt; B&quot;&gt;

</PRE>


<P>



<PRE>
    &lt;!-- &lt;A comment&gt; --&gt;

</PRE>


<P>



<PRE>
    &lt;script&gt;if (a&lt;b &amp;&amp; a&gt;c)&lt;/script&gt;

</PRE>


<P>



<PRE>
    &lt;# Just data #&gt;

</PRE>


<P>



<PRE>
    &lt;![INCLUDE CDATA [ &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ]]&gt;

</PRE>


<P>

If <FONT SIZE="-1">HTML</FONT> comments include other tags, those solutions would also break
on text like this:
<P>



<PRE>
    &lt;!-- This section commented out.
        &lt;B&gt;You can't see me!&lt;/B&gt;
    --&gt;

</PRE>


<A NAME="lbAH">&nbsp;</A>
<H2>How do I extract URLs?</H2>

<A NAME="ixAAH"></A>
You can easily extract all sorts of URLs from <FONT SIZE="-1">HTML</FONT> with
<TT>&quot;HTML::SimpleLinkExtor&quot;</TT> which handles anchors, images, objects,
frames, and many other tags that can contain a <FONT SIZE="-1">URL</FONT>.  If you need
anything more complex, you can create your own subclass of
<TT>&quot;HTML::LinkExtor&quot;</TT> or <TT>&quot;HTML::Parser&quot;</TT>.  You might even use
<TT>&quot;HTML::SimpleLinkExtor&quot;</TT> as an example for something specifically
suited to your needs.
<P>

You can use URI::Find to extract URLs from an arbitrary text document.
<P>

Less complete solutions involving regular expressions can save
you a lot of processing time if you know that the input is simple.  One
solution from Tom Christiansen runs 100 times faster than most
module based approaches but only extracts URLs from anchors where the first
attribute is <FONT SIZE="-1">HREF</FONT> and there are no other attributes.
<P>



<PRE>
        #!/usr/bin/perl -n00
        # qxurl - <A HREF="mailto:tchrist@perl.com">tchrist@perl.com</A>
        print &quot;$2\n&quot; while m{
            &lt; \s*
              A \s+ HREF \s* = \s* ([&quot;']) (.*?) \1
            \s* &gt;
        }gsix;

</PRE>


<A NAME="lbAI">&nbsp;</A>
<H2>How do I download a file from the user's machine?  How do I open a file on another machine?</H2>

<A NAME="ixAAI"></A>
In this case, download means to use the file upload feature of <FONT SIZE="-1">HTML</FONT>
forms.  You allow the web surfer to specify a file to send to your web
server.  To you it looks like a download, and to the user it looks
like an upload.  No matter what you call it, you do it with what's
known as <B>multipart/form-data</B> encoding.  The <FONT SIZE="-1">CGI</FONT>.pm module (which
comes with Perl as part of the Standard Library) supports this in the
<I>start_multipart_form()</I> method, which isn't the same as the <I>startform()</I>
method.
<P>

See the section in the <FONT SIZE="-1">CGI</FONT>.pm documentation on file uploads for code
examples and details.
<A NAME="lbAJ">&nbsp;</A>
<H2>How do I make a pop-up menu in <FONT SIZE="-1">HTML</FONT>?</H2>

<A NAME="ixAAJ"></A>
Use the <B>&lt;</B><FONT SIZE="-1"><B>SELECT</B></FONT><B>&gt;</B> and <B>&lt;</B><FONT SIZE="-1"><B>OPTION</B></FONT><B>&gt;</B> tags.  The <FONT SIZE="-1">CGI</FONT>.pm
module (available from <FONT SIZE="-1">CPAN</FONT>) supports this widget, as well as many
others, including some that it cleverly synthesizes on its own.
<A NAME="lbAK">&nbsp;</A>
<H2>How do I fetch an <FONT SIZE="-1">HTML</FONT> file?</H2>

<A NAME="ixAAK"></A>
One approach, if you have the lynx text-based <FONT SIZE="-1">HTML</FONT> browser installed
on your system, is this:
<P>



<PRE>
    $html_code = `lynx -source $url`;
    $text_data = `lynx -dump $url`;

</PRE>


<P>

The libwww-perl (<FONT SIZE="-1">LWP</FONT>) modules from <FONT SIZE="-1">CPAN</FONT> provide a more powerful way
to do this.  They don't require lynx, but like lynx, can still work
through proxies:
<P>



<PRE>
    # simplest version
    use LWP::Simple;
    $content = get($URL);

</PRE>


<P>



<PRE>
    # or print HTML from a URL
    use LWP::Simple;
    getprint &quot;<A HREF="http://www.linpro.no/lwp/">http://www.linpro.no/lwp/</A>&quot;;

</PRE>


<P>



<PRE>
    # or print ASCII from HTML from a URL
    # also need HTML-Tree package from CPAN
    use LWP::Simple;
    use HTML::Parser;
    use HTML::FormatText;
    my ($html, $ascii);
    $html = get(&quot;<A HREF="http://www.perl.com/">http://www.perl.com/</A>&quot;);
    defined $html
        or die &quot;Can't fetch HTML from <A HREF="http://www.perl.com/">http://www.perl.com/</A>&quot;;
    $ascii = HTML::FormatText-&gt;new-&gt;format(parse_html($html));
    print $ascii;

</PRE>


<A NAME="lbAL">&nbsp;</A>
<H2>How do I automate an <FONT SIZE="-1">HTML</FONT> form submission?</H2>

<A NAME="ixAAL"></A>
If you're submitting values using the <FONT SIZE="-1">GET</FONT> method, create a <FONT SIZE="-1">URL</FONT> and encode
the form using the <TT>&quot;query_form&quot;</TT> method:
<P>



<PRE>
    use LWP::Simple;
    use URI::URL;

</PRE>


<P>



<PRE>
    my $url = url('<A HREF="http://www.perl.com/cgi-bin/cpan_mod');">http://www.perl.com/cgi-bin/cpan_mod');</A>
    $url-&gt;query_form(module =&gt; 'DB_File', readme =&gt; 1);
    $content = get($url);

</PRE>


<P>

If you're using the <FONT SIZE="-1">POST</FONT> method, create your own user agent and encode
the content appropriately.
<P>



<PRE>
    use HTTP::Request::Common qw(POST);
    use LWP::UserAgent;

</PRE>


<P>



<PRE>
    $ua = LWP::UserAgent-&gt;new();
    my $req = POST '<A HREF="http://www.perl.com/cgi-bin/cpan_mod',">http://www.perl.com/cgi-bin/cpan_mod',</A>
                   [ module =&gt; 'DB_File', readme =&gt; 1 ];
    $content = $ua-&gt;request($req)-&gt;as_string;

</PRE>


<A NAME="lbAM">&nbsp;</A>
<H2>How do I decode or create those %-encodings on the web?</H2>

<A NAME="ixAAM"></A>
If you are writing a <FONT SIZE="-1">CGI</FONT> script, you should be using the <FONT SIZE="-1">CGI</FONT>.pm module
that comes with perl, or some other equivalent module.  The <FONT SIZE="-1">CGI</FONT> module
automatically decodes queries for you, and provides an <I>escape()</I>
function to handle encoding.
<P>

The best source of detailed information on <FONT SIZE="-1">URI</FONT> encoding is <FONT SIZE="-1">RFC</FONT> 2396.
Basically, the following substitutions do it:
<P>



<PRE>
    s/([^\w()'*~!.-])/sprintf '%%%02x', ord $1/eg;   # encode

</PRE>


<P>



<PRE>
    s/%([A-Fa-f\d]{2})/chr hex $1/eg;            # decode

</PRE>


<P>

However, you should only apply them to individual <FONT SIZE="-1">URI</FONT> components, not
the entire <FONT SIZE="-1">URI</FONT>, otherwise you'll lose information and generally mess
things up.  If that didn't explain it, don't worry.  Just go read
section 2 of the <FONT SIZE="-1">RFC</FONT>, it's probably the best explanation there is.
<P>

<FONT SIZE="-1">RFC</FONT> 2396 also contains a lot of other useful information, including a
regexp for breaking any arbitrary <FONT SIZE="-1">URI</FONT> into components (Appendix B).
<A NAME="lbAN">&nbsp;</A>
<H2>How do I redirect to another page?</H2>

<A NAME="ixAAN"></A>
Specify the complete <FONT SIZE="-1">URL</FONT> of the destination (even if it is on the same
server). This is one of the two different kinds of <FONT SIZE="-1">CGI</FONT> ``Location:''
responses which are defined in the <FONT SIZE="-1">CGI</FONT> specification for a Parsed Headers
script. The other kind (an absolute URLpath) is resolved internally to
the server without any <FONT SIZE="-1">HTTP</FONT> redirection. The <FONT SIZE="-1">CGI</FONT> specifications do not
allow relative URLs in either case.
<P>

Use of <FONT SIZE="-1">CGI</FONT>.pm is strongly recommended.  This example shows redirection
with a complete <FONT SIZE="-1">URL</FONT>. This redirection is handled by the web browser.
<P>



<PRE>
      use CGI qw/:standard/;

</PRE>


<P>



<PRE>
      my $url = '<A HREF="http://www.cpan.org/';">http://www.cpan.org/';</A>
      print redirect($url);

</PRE>


<P>

This example shows a redirection with an absolute URLpath.  This
redirection is handled by the local web server.
<P>



<PRE>
      my $url = '/CPAN/index.html';
      print redirect($url);

</PRE>


<P>

But if coded directly, it could be as follows (the final ``\n'' is
shown separately, for clarity), using either a complete <FONT SIZE="-1">URL</FONT> or
an absolute URLpath.
<P>



<PRE>
      print &quot;Location: $url\n&quot;;   # CGI response header
      print &quot;\n&quot;;                 # end of headers

</PRE>


<A NAME="lbAO">&nbsp;</A>
<H2>How do I put a password on my web pages?</H2>

<A NAME="ixAAO"></A>
To enable authentication for your web server, you need to configure
your web server.  The configuration is different for different sorts
of web servers---apache does it differently from iPlanet which does
it differently from <FONT SIZE="-1">IIS</FONT>.  Check your web server documentation for
the details for your particular server.
<A NAME="lbAP">&nbsp;</A>
<H2>How do I edit my .htpasswd and .htgroup files with Perl?</H2>

<A NAME="ixAAP"></A>
The HTTPD::UserAdmin and HTTPD::GroupAdmin modules provide a
consistent <FONT SIZE="-1">OO</FONT> interface to these files, regardless of how they're
stored.  Databases may be text, dbm, Berkeley <FONT SIZE="-1">DB</FONT> or any database with
a <FONT SIZE="-1">DBI</FONT> compatible driver.  HTTPD::UserAdmin supports files used by the
`Basic' and `Digest' authentication schemes.  Here's an example:
<P>



<PRE>
    use HTTPD::UserAdmin ();
    HTTPD::UserAdmin
          -&gt;new(DB =&gt; &quot;/foo/.htpasswd&quot;)
          -&gt;add($username =&gt; $password);

</PRE>


<A NAME="lbAQ">&nbsp;</A>
<H2>How do I make sure users can't enter values into a form that cause my <FONT SIZE="-1">CGI</FONT> script to do bad things?</H2>

<A NAME="ixAAQ"></A>
See the security references listed in the <FONT SIZE="-1">CGI</FONT> Meta <FONT SIZE="-1">FAQ</FONT>
<P>



<PRE>
        <A HREF="http://www.perl.org/CGI_MetaFAQ.php">http://www.perl.org/CGI_MetaFAQ.html</A>

</PRE>


<A NAME="lbAR">&nbsp;</A>
<H2>How do I parse a mail header?</H2>

<A NAME="ixAAR"></A>
For a quick-and-dirty solution, try this solution derived
from ``split'' in perlfunc:
<P>



<PRE>
    $/ = '';
    $header = &lt;MSG&gt;;
    $header =~ s/\n\s+/ /g;      # merge continuation lines
    %head = ( UNIX_FROM_LINE, split /^([-\w]+):\s*/m, $header );

</PRE>


<P>

That solution doesn't do well if, for example, you're trying to
maintain all the Received lines.  A more complete approach is to use
the Mail::Header module from <FONT SIZE="-1">CPAN</FONT> (part of the MailTools package).
<A NAME="lbAS">&nbsp;</A>
<H2>How do I decode a <FONT SIZE="-1">CGI</FONT> form?</H2>

<A NAME="ixAAS"></A>
You use a standard module, probably <FONT SIZE="-1">CGI</FONT>.pm.  Under no circumstances
should you attempt to do so by hand!
<P>

You'll see a lot of <FONT SIZE="-1">CGI</FONT> programs that blindly read from <FONT SIZE="-1">STDIN</FONT> the number
of bytes equal to <FONT SIZE="-1">CONTENT_LENGTH</FONT> for POSTs, or grab <FONT SIZE="-1">QUERY_STRING</FONT> for
decoding GETs.  These programs are very poorly written.  They only work
sometimes.  They typically forget to check the return value of the <I>read()</I>
system call, which is a cardinal sin.  They don't handle <FONT SIZE="-1">HEAD</FONT> requests.
They don't handle multipart forms used for file uploads.  They don't deal
with <FONT SIZE="-1">GET/POST</FONT> combinations where query fields are in more than one place.
They don't deal with keywords in the query string.
<P>

In short, they're bad hacks.  Resist them at all costs.  Please do not be
tempted to reinvent the wheel.  Instead, use the <FONT SIZE="-1">CGI</FONT>.pm or CGI_Lite.pm
(available from <FONT SIZE="-1">CPAN</FONT>), or if you're trapped in the module-free land
of perl1 .. perl4, you might look into cgi-lib.pl (available from
<A HREF="http://cgi-lib.stanford.edu/cgi-lib/">http://cgi-lib.stanford.edu/cgi-lib/</A> ).
<P>

Make sure you know whether to use a <FONT SIZE="-1">GET</FONT> or a <FONT SIZE="-1">POST</FONT> in your form.
GETs should only be used for something that doesn't update the server.
Otherwise you can get mangled databases and repeated feedback mail
messages.  The fancy word for this is ``idempotency''.  This simply
means that there should be no difference between making a <FONT SIZE="-1">GET</FONT> request
for a particular <FONT SIZE="-1">URL</FONT> once or multiple times.  This is because the
<FONT SIZE="-1">HTTP</FONT> protocol definition says that a <FONT SIZE="-1">GET</FONT> request may be cached by the
browser, or server, or an intervening proxy.  <FONT SIZE="-1">POST</FONT> requests cannot be
cached, because each request is independent and matters.  Typically,
<FONT SIZE="-1">POST</FONT> requests change or depend on state on the server (query or update
a database, send mail, or purchase a computer).
<A NAME="lbAT">&nbsp;</A>
<H2>How do I check a valid mail address?</H2>

<A NAME="ixAAT"></A>
You can't, at least, not in real time.  Bummer, eh?
<P>

Without sending mail to the address and seeing whether there's a human
on the other hand to answer you, you cannot determine whether a mail
address is valid.  Even if you apply the mail header standard, you
can have problems, because there are deliverable addresses that aren't
<FONT SIZE="-1">RFC-822</FONT> (the mail header standard) compliant, and addresses that aren't
deliverable which are compliant.
<P>

You can use the Email::Valid or RFC::RFC822::Address which check
the format of the address, although they cannot actually tell you
if it is a deliverable address (i.e. that mail to the address
will not bounce).  Modules like Mail::CheckUser and Mail::EXPN
try to interact with the domain name system or particular
mail servers to learn even more, but their methods do not
work everywhere---especially for security conscious administrators.
<P>

Many are tempted to try to eliminate many frequently-invalid
mail addresses with a simple regex, such as
<TT>&quot;/^[\w.-]+\@(?:[\w-]+\.)+\w+$/&quot;</TT>.  It's a very bad idea.  However,
this also throws out many valid ones, and says nothing about
potential deliverability, so it is not suggested.  Instead, see
<A HREF="http://www.cpan.org/authors/Tom_Christiansen/scripts/ckaddr.gz">http://www.cpan.org/authors/Tom_Christiansen/scripts/ckaddr.gz</A> ,
which actually checks against the full <FONT SIZE="-1">RFC</FONT> spec (except for nested
comments), looks for addresses you may not wish to accept mail to
(say, Bill Clinton or your postmaster), and then makes sure that the
hostname given can be looked up in the <FONT SIZE="-1">DNS</FONT> <FONT SIZE="-1">MX</FONT> records.  It's not fast,
but it works for what it tries to do.
<P>

Our best advice for verifying a person's mail address is to have them
enter their address twice, just as you normally do to change a password.
This usually weeds out typos.  If both versions match, send
mail to that address with a personal message that looks somewhat like:
<P>



<PRE>
    Dear <A HREF="mailto:someuser@host.com">someuser@host.com</A>,

</PRE>


<P>



<PRE>
    Please confirm the mail address you gave us Wed May  6 09:38:41
    MDT 1998 by replying to this message.  Include the string
    &quot;Rumpelstiltskin&quot; in that reply, but spelled in reverse; that is,
    start with &quot;Nik...&quot;.  Once this is done, your confirmed address will
    be entered into our records.

</PRE>


<P>

If you get the message back and they've followed your directions,
you can be reasonably assured that it's real.
<P>

A related strategy that's less open to forgery is to give them a <FONT SIZE="-1">PIN</FONT>
(personal <FONT SIZE="-1">ID</FONT> number).  Record the address and <FONT SIZE="-1">PIN</FONT> (best that it be a
random one) for later processing.  In the mail you send, ask them to
include the <FONT SIZE="-1">PIN</FONT> in their reply.  But if it bounces, or the message is
included via a ``vacation'' script, it'll be there anyway.  So it's
best to ask them to mail back a slight alteration of the <FONT SIZE="-1">PIN</FONT>, such as
with the characters reversed, one added or subtracted to each digit, etc.
<A NAME="lbAU">&nbsp;</A>
<H2>How do I decode a <FONT SIZE="-1">MIME/BASE64</FONT> string?</H2>

<A NAME="ixAAU"></A>
The MIME-Base64 package (available from <FONT SIZE="-1">CPAN</FONT>) handles this as well as
the <FONT SIZE="-1">MIME/QP</FONT> encoding.  Decoding <FONT SIZE="-1">BASE64</FONT> becomes as simple as:
<P>



<PRE>
    use MIME::Base64;
    $decoded = decode_base64($encoded);

</PRE>


<P>

The MIME-Tools package (available from <FONT SIZE="-1">CPAN</FONT>) supports extraction with
decoding of <FONT SIZE="-1">BASE64</FONT> encoded attachments and content directly from email
messages.
<P>

If the string to decode is short (less than 84 bytes long)
a more direct approach is to use the <I>unpack()</I> function's ``u''
format after minor transliterations:
<P>



<PRE>
    tr#A-Za-z0-9+/##cd;                   # remove non-base64 chars
    tr#A-Za-z0-9+/# -_#;                  # convert to uuencoded format
    $len = pack(&quot;c&quot;, 32 + 0.75*length);   # compute length byte
    print unpack(&quot;u&quot;, $len . $_);         # uudecode and print

</PRE>


<A NAME="lbAV">&nbsp;</A>
<H2>How do I return the user's mail address?</H2>

<A NAME="ixAAV"></A>
On systems that support getpwuid, the $&lt; variable, and the
Sys::Hostname module (which is part of the standard perl distribution),
you can probably try using something like this:
<P>



<PRE>
    use Sys::Hostname;
    $address = sprintf('%s@%s', scalar getpwuid($&lt;), hostname);

</PRE>


<P>

Company policies on mail address can mean that this generates addresses
that the company's mail system will not accept, so you should ask for
users' mail addresses when this matters.  Furthermore, not all systems
on which Perl runs are so forthcoming with this information as is Unix.
<P>

The Mail::Util module from <FONT SIZE="-1">CPAN</FONT> (part of the MailTools package) provides a
<I>mailaddress()</I> function that tries to guess the mail address of the user.
It makes a more intelligent guess than the code above, using information
given when the module was installed, but it could still be incorrect.
Again, the best way is often just to ask the user.
<A NAME="lbAW">&nbsp;</A>
<H2>How do I send mail?</H2>

<A NAME="ixAAW"></A>
Use the <TT>&quot;sendmail&quot;</TT> program directly:
<P>



<PRE>
    open(SENDMAIL, &quot;|/usr/lib/sendmail -oi -t -odq&quot;)
                        or die &quot;Can't fork for sendmail: $!\n&quot;;
    print SENDMAIL &lt;&lt;&quot;EOF&quot;;
    From: User Originating Mail &lt;me\@host&gt;
    To: Final Destination &lt;you\@otherhost&gt;
    Subject: A relevant subject line

</PRE>


<P>



<PRE>
    Body of the message goes here after the blank line
    in as many lines as you like.
    EOF
    close(SENDMAIL)     or warn &quot;sendmail didn't close nicely&quot;;

</PRE>


<P>

The <B>-oi</B> option prevents sendmail from interpreting a line consisting
of a single dot as ``end of message''.  The <B>-t</B> option says to use the
headers to decide who to send the message to, and <B>-odq</B> says to put
the message into the queue.  This last option means your message won't
be immediately delivered, so leave it out if you want immediate
delivery.
<P>

Alternate, less convenient approaches include calling mail (sometimes
called mailx) directly or simply opening up port 25 have having an
intimate conversation between just you and the remote <FONT SIZE="-1">SMTP</FONT> daemon,
probably sendmail.
<P>

Or you might be able use the <FONT SIZE="-1">CPAN</FONT> module Mail::Mailer:
<P>



<PRE>
    use Mail::Mailer;

</PRE>


<P>



<PRE>
    $mailer = Mail::Mailer-&gt;new();
    $mailer-&gt;open({ From    =&gt; $from_address,
                    To      =&gt; $to_address,
                    Subject =&gt; $subject,
                  })
        or die &quot;Can't open: $!\n&quot;;
    print $mailer $body;
    $mailer-&gt;close();

</PRE>


<P>

The Mail::Internet module uses Net::SMTP which is less Unix-centric than
Mail::Mailer, but less reliable.  Avoid raw <FONT SIZE="-1">SMTP</FONT> commands.  There
are many reasons to use a mail transport agent like sendmail.  These
include queuing, <FONT SIZE="-1">MX</FONT> records, and security.
<A NAME="lbAX">&nbsp;</A>
<H2>How do I use <FONT SIZE="-1">MIME</FONT> to make an attachment to a mail message?</H2>

<A NAME="ixAAX"></A>
This answer is extracted directly from the MIME::Lite documentation.
Create a multipart message (i.e., one with attachments).
<P>



<PRE>
    use MIME::Lite;

</PRE>


<P>



<PRE>
    ### Create a new multipart message:
    $msg = MIME::Lite-&gt;new(
                 From    =&gt;'<A HREF="mailto:me@myhost.com">me@myhost.com</A>',
                 To      =&gt;'<A HREF="mailto:you@yourhost.com">you@yourhost.com</A>',
                 Cc      =&gt;'<A HREF="mailto:some@other.com">some@other.com</A>, <A HREF="mailto:some@more.com">some@more.com</A>',
                 Subject =&gt;'A message with 2 parts...',
                 Type    =&gt;'multipart/mixed'
                 );

</PRE>


<P>



<PRE>
    ### Add parts (each &quot;attach&quot; has same arguments as &quot;new&quot;):
    $msg-&gt;attach(Type     =&gt;'TEXT',
                 Data     =&gt;&quot;Here's the GIF file you wanted&quot;
                 );
    $msg-&gt;attach(Type     =&gt;'image/gif',
                 Path     =&gt;'aaa000123.gif',
                 Filename =&gt;'logo.gif'
                 );

</PRE>


<P>



<PRE>
    $text = $msg-&gt;as_string;

</PRE>


<P>

MIME::Lite also includes a method for sending these things.
<P>



<PRE>
    $msg-&gt;send;

</PRE>


<P>

This defaults to using sendmail but can be customized to use
<FONT SIZE="-1">SMTP</FONT> via Net::SMTP.
<A NAME="lbAY">&nbsp;</A>
<H2>How do I read mail?</H2>

<A NAME="ixAAY"></A>
While you could use the Mail::Folder module from <FONT SIZE="-1">CPAN</FONT> (part of the
MailFolder package) or the Mail::Internet module from <FONT SIZE="-1">CPAN</FONT> (part
of the MailTools package), often a module is overkill.  Here's a
mail sorter.
<P>



<PRE>
    #!/usr/bin/perl

</PRE>


<P>



<PRE>
    my(@msgs, @sub);
    my $msgno = -1;
    $/ = '';                    # paragraph reads
    while (&lt;&gt;) {
        if (/^From /m) {
            /^Subject:\s*(?:Re:\s*)*(.*)/mi;
            $sub[++$msgno] = lc($1) || '';
        }
        $msgs[$msgno] .= $_;
    }
    for my $i (sort { $sub[$a] cmp $sub[$b] || $a &lt;=&gt; $b } (0 .. $#msgs)) {
        print $msgs[$i];
    }

</PRE>


<P>

Or more succinctly,
<P>



<PRE>
    #!/usr/bin/perl -n00
    # bysub2 - awkish sort-by-subject
    BEGIN { $msgno = -1 }
    $sub[++$msgno] = (/^Subject:\s*(?:Re:\s*)*(.*)/mi)[0] if /^From/m;
    $msg[$msgno] .= $_;
    END { print @msg[ sort { $sub[$a] cmp $sub[$b] || $a &lt;=&gt; $b } (0 .. $#msg) ] }

</PRE>


<A NAME="lbAZ">&nbsp;</A>
<H2>How do I find out my hostname/domainname/IP address?</H2>

<A NAME="ixAAZ"></A>
The normal way to find your own hostname is to call the <TT>`hostname`</TT>
program.  While sometimes expedient, this has some problems, such as
not knowing whether you've got the canonical name or not.  It's one of
those tradeoffs of convenience versus portability.
<P>

The Sys::Hostname module (part of the standard perl distribution) will
give you the hostname after which you can find out the <FONT SIZE="-1">IP</FONT> address
(assuming you have working <FONT SIZE="-1">DNS</FONT>) with a <I>gethostbyname()</I> call.
<P>



<PRE>
    use Socket;
    use Sys::Hostname;
    my $host = hostname();
    my $addr = inet_ntoa(scalar gethostbyname($host || 'localhost'));

</PRE>


<P>

Probably the simplest way to learn your <FONT SIZE="-1">DNS</FONT> domain name is to grok
it out of /etc/resolv.conf, at least under Unix.  Of course, this
assumes several things about your resolv.conf configuration, including
that it exists.
<P>

(We still need a good <FONT SIZE="-1">DNS</FONT> domain name-learning method for non-Unix
systems.)
<A NAME="lbBA">&nbsp;</A>
<H2>How do I fetch a news article or the active newsgroups?</H2>

<A NAME="ixABA"></A>
Use the Net::NNTP or News::NNTPClient modules, both available from <FONT SIZE="-1">CPAN</FONT>.
This can make tasks like fetching the newsgroup list as simple as
<P>



<PRE>
    perl -MNews::NNTPClient
      -e 'print News::NNTPClient-&gt;new-&gt;list(&quot;newsgroups&quot;)'

</PRE>


<A NAME="lbBB">&nbsp;</A>
<H2>How do I fetch/put an <FONT SIZE="-1">FTP</FONT> file?</H2>

<A NAME="ixABB"></A>
LWP::Simple (available from <FONT SIZE="-1">CPAN</FONT>) can fetch but not put.  Net::FTP (also
available from <FONT SIZE="-1">CPAN</FONT>) is more complex but can put as well as fetch.
<A NAME="lbBC">&nbsp;</A>
<H2>How can I do <FONT SIZE="-1">RPC</FONT> in Perl?</H2>

<A NAME="ixABC"></A>
A <FONT SIZE="-1">DCE::RPC</FONT> module is being developed (but is not yet available) and
will be released as part of the DCE-Perl package (available from
<FONT SIZE="-1">CPAN</FONT>).  The rpcgen suite, available from CPAN/authors/id/JAKE/, is
an <FONT SIZE="-1">RPC</FONT> stub generator and includes an <FONT SIZE="-1">RPC::ONC</FONT> module.
<A NAME="lbBD">&nbsp;</A>
<H2>AUTHOR AND COPYRIGHT</H2>

<A NAME="ixABD"></A>
Copyright (c) 1997-2002 Tom Christiansen and Nathan Torkington.
All rights reserved.
<P>

This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
<P>

Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">DESCRIPTION</A><DD>
<DT><A HREF="#lbAD">What is the correct form of response from a <FONT SIZE="-1">CGI</FONT> script?</A><DD>
<DT><A HREF="#lbAE">My <FONT SIZE="-1">CGI</FONT> script runs from the command line but not the browser.  (500 Server Error)</A><DD>
<DT><A HREF="#lbAF">How can I get better error messages from a <FONT SIZE="-1">CGI</FONT> program?</A><DD>
<DT><A HREF="#lbAG">How do I remove <FONT SIZE="-1">HTML</FONT> from a string?</A><DD>
<DT><A HREF="#lbAH">How do I extract URLs?</A><DD>
<DT><A HREF="#lbAI">How do I download a file from the user's machine?  How do I open a file on another machine?</A><DD>
<DT><A HREF="#lbAJ">How do I make a pop-up menu in <FONT SIZE="-1">HTML</FONT>?</A><DD>
<DT><A HREF="#lbAK">How do I fetch an <FONT SIZE="-1">HTML</FONT> file?</A><DD>
<DT><A HREF="#lbAL">How do I automate an <FONT SIZE="-1">HTML</FONT> form submission?</A><DD>
<DT><A HREF="#lbAM">How do I decode or create those 0.000000e+00ncodings on the web?</A><DD>
<DT><A HREF="#lbAN">How do I redirect to another page?</A><DD>
<DT><A HREF="#lbAO">How do I put a password on my web pages?</A><DD>
<DT><A HREF="#lbAP">How do I edit my .htpasswd and .htgroup files with Perl?</A><DD>
<DT><A HREF="#lbAQ">How do I make sure users can't enter values into a form that cause my <FONT SIZE="-1">CGI</FONT> script to do bad things?</A><DD>
<DT><A HREF="#lbAR">How do I parse a mail header?</A><DD>
<DT><A HREF="#lbAS">How do I decode a <FONT SIZE="-1">CGI</FONT> form?</A><DD>
<DT><A HREF="#lbAT">How do I check a valid mail address?</A><DD>
<DT><A HREF="#lbAU">How do I decode a <FONT SIZE="-1">MIME/BASE64</FONT> string?</A><DD>
<DT><A HREF="#lbAV">How do I return the user's mail address?</A><DD>
<DT><A HREF="#lbAW">How do I send mail?</A><DD>
<DT><A HREF="#lbAX">How do I use <FONT SIZE="-1">MIME</FONT> to make an attachment to a mail message?</A><DD>
<DT><A HREF="#lbAY">How do I read mail?</A><DD>
<DT><A HREF="#lbAZ">How do I find out my hostname/domainname/IP address?</A><DD>
<DT><A HREF="#lbBA">How do I fetch a news article or the active newsgroups?</A><DD>
<DT><A HREF="#lbBB">How do I fetch/put an <FONT SIZE="-1">FTP</FONT> file?</A><DD>
<DT><A HREF="#lbBC">How can I do <FONT SIZE="-1">RPC</FONT> in Perl?</A><DD>
<DT><A HREF="#lbBD">AUTHOR AND COPYRIGHT</A><DD>
</DL>

</div>






</div>




</body>
</html>
