
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<title>irb-beta</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="/global/main.css" title="default">
</head>

<body>



<div id="container">


<div id="content">

<div id='catHeader'><table width='100%'><tr><td>
<H1>irb-beta</H1>
Section: User Commands  (1)<BR>Updated: May 2001<BR>
</td><td align='right' valign='bottom'><div class='ad_header_right'></div></td></tr></table></div></div>
<div id='categories'>
<div class='ad_man_right'>
</div>

<A NAME="lbAB">&nbsp;</A>
<H2>What is irb?</H2>

<P>

irb stands for `interactive ruby'. irb is a tool to execute interactively
ruby expressions read from stdin. 
<A NAME="lbAC">&nbsp;</A>
<H2>Invoking</H2>

<P>

<PRE>
    % ruby -r irb -e0
    % irb
</PRE>

Either of the aboves. In the former style, options can be specified
as follows:
<PRE>
    % ruby -r irb -e0 -- -v
</PRE>

<A NAME="lbAD">&nbsp;</A>
<H2>Usage</H2>

<P>

Use of irb is easy if you know ruby.  Executing irb, prompts are 
displayed as follows. Then, enter expression of ruby. A input is
executed when it is syntacticaly completed. 
<PRE>
    dim% irb
    irb(main):001:0&gt; 1+2
    3
    irb(main):002:0&gt; class Foo
    irb(main):003:1&gt;  def foo
    irb(main):004:2&gt;    print 1
    irb(main):005:2&gt;  end
    irb(main):006:1&gt; end
    nil
    irb(main):007:0&gt; 
</PRE>

And, Readline extesion module can be used with irb. Using Readline
is the standard default action if Readline is installed. 
<A NAME="lbAE">&nbsp;</A>
<H2>Command line option</H2>

<P>

<PRE>
    irb.rb [options] file_name opts
    options:
    -f              suppress read ~/.irbrc 
    -m              bc mode (fraction or matrix are available)
    -d                set $DEBUG  to true (same as `ruby -d')
    -r load-module    same as `ruby -r'
    --inspect       uses `inspect' for output (the default except bc mode)
    --noinspect     doesn't uses inspect for output
    --readline      uses Readline extension module
    --noreadline            doesn't use Readline extension module
    --prompt prompt-mode
    --prompt-mode prompt-mode
</PRE>

<PRE>
    switches prompt mode. Pre-defined prompt modes are
    `defalut', `simple', `xmp' and `inf-ruby'
</PRE>

<PRE>
    --inf-ruby-mode   uses prompt appreciate for inf-ruby-mode on emacs. 
</PRE>

<PRE>
    Suppresses --readline. 
</PRE>

<PRE>
    --simple-prompt   simple prompt mode
    --noprompt      no prompt
    --tracer        display trace for each execution of commands.
    --back-trace-limit n
</PRE>

<PRE>
    displayes backtrace top n and tail n. The default
    value is 16. 
</PRE>

<PRE>
    --irb_debug n           sets internal debug level to n (It shouldn't be used)
    -v, --version           prints the version of irb
</PRE>

<A NAME="lbAF">&nbsp;</A>
<H2>Configurations</H2>

<P>

irb reads `~/.irbrc' when it is invoked. If `~/.irbrb' doesn't exist
irb try to read in the order `.irbrc', `irb.rc', `_irbrc' then `$irbrc'. 
The following is altanative to the command line option. To use them
type as follows in an irb session. 
<PRE>
    IRB.conf[:IRB_NAME]=&quot;irb&quot;
    IRB.conf[:MATH_MODE]=false
    IRB.conf[:USE_TRACER]=false
    IRB.conf[:USE_LOADER]=false
    IRB.conf[:IGNORE_SIGINT]=true
    IRB.conf[:IGNORE_EOF]=false
    IRB.conf[:INSPECT_MODE]=nil
    IRB.conf[:IRB_RC] = nil
    IRB.conf[:BACK_TRACE_LIMIT]=16
    IRB.conf[:USE_LOADER] = false
    IRB.conf[:USE_READLINE] = nil
    IRB.conf[:USE_TRACER] = false
    IRB.conf[:IGNORE_SIGINT] = true
    IRB.conf[:IGNORE_EOF] = false
    IRB.conf[:PROMPT_MODE] = :DEFALUT
    IRB.conf[:PROMPT] = {...}
    IRB.conf[:DEBUG_LEVEL]=0
    IRB.conf[:VERBOSE]=true
</PRE>

<A NAME="lbAG">&nbsp;</A>
<H2>Customizing prompt</H2>

<P>

To costomize the prompt you set a variable
<PRE>
    IRB.conf[:PROMPT]
</PRE>

For example, describe as follows in `.irbrc'. 
<PRE>
    IRB.conf[:PROMPT][:MY_PROMPT] = { # name of prompt mode
      :PROMPT_I =&gt; nil,           # normal prompt
      :PROMPT_S =&gt; nil,           # prompt for continuated strings
      :PROMPT_C =&gt; nil,           # prompt for continuated statement
      :RETURN =&gt; &quot;    ==&gt;%s\n&quot;    # format to return value
    }
</PRE>

Then, invoke irb with the above prompt mode by
<PRE>
    % irb --prompt my-prompt
</PRE>

Or add the following in `.irbrc'. 
<PRE>
    IRB.conf[:PROMPT_MODE] = :MY_PROMPT
</PRE>

Constants PROMPT_I, PROMPT_S and PROMPT_C specifies the format. 
In the prompt specification, some special strings are available. 
<PRE>
    %N  command name which is running
    %m  to_s of main object (self)
    %M  inspect of main object (self)
    %l  type of string(&quot;, ', /, ]), `]' is inner %w[...]
    %NNi        indent level. NN is degits and means as same as printf(&quot;%NNd&quot;). 
          It can be ommited
    %NNn        line number. 
    %%    %
</PRE>

For instance, the default prompt mode is defined as follows:
IRB.conf[:PROMPT_MODE][:DEFAULT] = {
<P>
<DL COMPACT>
<DT>
<DD>
<B>PROMPT_I =&gt; &quot;%N(%m):%03n:%i&gt; &quot;,</B>

<P>
<P>
<DT>
<DD>
<B>PROMPT_S =&gt; &quot;%N(%m):%03n:%i%l &quot;,</B>

<P>
<P>
<DT>
<DD>
<B>PROMPT_C =&gt; &quot;%N(%m):%03n:%i* &quot;,</B>

<P>
<P>
<DT>
<DD>
<B>RETURN =&gt; &quot;%s\n&quot;</B>

} 
RETURN is used to printf. 
</DL>
<A NAME="lbAH">&nbsp;</A>
<H2>Configurating subirb</H2>

<P>

The command line option or IRB.conf specify the default behavior of
(sub)irb. On the other hand, each conf of in the next sction `6. Command' 
is used to individually configurate (sub)irb. 
If proc is set to IRB.conf[:IRB_RC], its subirb will be invoked after
execution of that proc under giving the context of irb as its
aregument. By this mechanism each subirb can be configurated. 
<A NAME="lbAI">&nbsp;</A>
<H2>Command</H2>

<P>

For irb commands, both simple name and `irb_'-prefixed name are prepared. 
<P>
<DL COMPACT>
<DT>
<DD>
<B>exit, quit, irb_exit</B>

Quits (sub)irb. 
if you've done cb (see below), exit from the binding mode.
<P>
<P>
<DT>
<DD>
<B>conf, irb_context</B>

Displays current configuration. Modifing the configuration is
achieved by sending message to `conf'. 
<P>
<P>
<DT>
<DD>
<B>conf.back_trace_limit</B>

Sets display lines of backtrace as top n and tail n. 
The default value is 16.
<P>
<P>
<DT>
<DD>
<B>conf.debug_level = N</B>

Sets debug level of irb. 
<P>
<P>
<DT>
<DD>
<B>conf.ignore_eof = true/false</B>

Whether ^D (control-d) will be ignored or not. 
If false is set, ^D means quit. 
<P>
<P>
<DT>
<DD>
<B>conf.ignore_sigint= true/false</B>

Whether ^C (control-c) will be ignored or not. 
If false is set, ^D means quit.  If true, 
<P>
<PRE>
    during input:   cancel inputing then return to top level. 
    during execute: abondon current execution. 
</PRE>

<P>
<P>
<DT>
<DD>
<B>conf.inf_ruby_mode = true/false</B>

Whether inf-ruby-mode or not. The default value is false.
<P>
<P>
<DT>
<DD>
<B>conf.inspect_mode = true/false/nil</B>

Specifies inspect mode. 
true:  display inspect
false: display to_s
nil:   inspect mode in non math mode, 
<P>
<PRE>
    non inspect mode in math mode. 
</PRE>

<P>
<P>
<DT>
<DD>
<B>conf.irb_level</B>

The level of cb. 
<P>
<P>
<DT>
<DD>
<B>conf.math_mode</B>

Whether bc mode or not. 
<P>
<P>
<DT>
<DD>
<B>conf.use_loader = true/false</B>

Whether irb's own file reader method is used when load/require or not. 
This mode is globaly affected (irb wide). 
<P>
<P>
<DT>
<DD>
<B>conf.prompt_c</B>

prompt for a continuating statement (e.g, immediately after of `if')
<P>
<P>
<DT>
<DD>
<B>conf.prompt_i</B>

standard prompt
<P>
<P>
<DT>
<DD>
<B>conf.prompt_s</B>

prompt for a continuating string
<P>
<P>
<DT>
<DD>
<B>conf.rc</B>

Whether ~/.irbrc is read or not. 
<P>
<P>
<DT>
<DD>
<B>conf.use_prompt = true/false</B>

Prompting or not. 
<P>
<P>
<DT>
<DD>
<B>conf.use_readline = true/false/nil</B>

Whether readline is used or not. 
true: uses 
false: doen't use
nil: intends to use readline except for inf-reuby-mode (default)
<P>
<P>
<DT>
<DD>
<B>conf.verbose=T/F</B>

Whether verbose messages are display or not. 
<P>
<P>
<DT>
<DD>
<B>cb, irb_change_binding [obj]</B>

Enter new binding which has a distinct scope of local variables. 
If obj is given, obj will be self. 
<P>
<P>
<DT>
<DD>
<B>irb [obj]</B>

Invoke subirb. If obj is given, obj will be self. 
<P>
<P>
<DT>
<DD>
<B>jobs, irb_jobs</B>

List of subirb
<P>
<P>
<DT>
<DD>
<B>fg n, irb_fg n</B>

Switch into specified subirb. The following is candidates of n:
<P>
<PRE>
    irb number
    thhread
    irb object
    self(obj which is specified of irb obj)
</PRE>

<P>
<P>
<DT>
<DD>
<B>kill n, irb_kill n</B>

Kill subirb. The means of n is as same as the case of irb_fg. 
</DL>
<A NAME="lbAJ">&nbsp;</A>
<H2>System variable</H2>

<P>

<PRE>
    _  The latest value of evaluation (it is local)
</PRE>

<A NAME="lbAK">&nbsp;</A>
<H2>Session Example</H2>

<P>

<PRE>
    dim% ruby irb.rb
    irb(main):001:0&gt; irb                        # invoke subirb
    irb#1(main):001:0&gt; jobs                     # list of subirbs
    #0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : stop)
    #1-&gt;irb#1 on main (#&lt;Thread:0x40125d64&gt; : running)
    nil
    irb#1(main):002:0&gt; fg 0                     # switch job
    nil
    irb(main):002:0&gt; class Foo;end
    nil
    irb(main):003:0&gt; irb Foo                    # invoke subirb which has the 
</PRE>

<PRE>
    #              context of Foo
</PRE>

<PRE>
    irb#2(Foo):001:0&gt; def foo                   # define Foo#foo
    irb#2(Foo):002:1&gt;   print 1
    irb#2(Foo):003:1&gt; end
    nil
    irb#2(Foo):004:0&gt; fg 0                      # switch job
    nil
    irb(main):004:0&gt; jobs                       # list of job
    #0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : running)
    #1-&gt;irb#1 on main (#&lt;Thread:0x40125d64&gt; : stop)
    #2-&gt;irb#2 on Foo (#&lt;Thread:0x4011d54c&gt; : stop)
    nil
    irb(main):005:0&gt; Foo.instance_methods       # Foo#foo is defined asurely
    [&quot;foo&quot;]
    irb(main):006:0&gt; fg 2                       # switch job
    nil
    irb#2(Foo):005:0&gt; def bar                   # define Foo#bar
    irb#2(Foo):006:1&gt;  print &quot;bar&quot;
    irb#2(Foo):007:1&gt; end
    nil
    irb#2(Foo):010:0&gt;  Foo.instance_methods
    [&quot;bar&quot;, &quot;foo&quot;]
    irb#2(Foo):011:0&gt; fg 0                      
    nil
    irb(main):007:0&gt; f = Foo.new
    #&lt;Foo:0x4010af3c&gt;
    irb(main):008:0&gt; irb f                      # invoke subirb which has the
</PRE>

<PRE>
    #  context of f (instance of Foo)
</PRE>

<PRE>
    irb#3(#&lt;Foo:0x4010af3c&gt;):001:0&gt; jobs
    #0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : stop)
    #1-&gt;irb#1 on main (#&lt;Thread:0x40125d64&gt; : stop)
    #2-&gt;irb#2 on Foo (#&lt;Thread:0x4011d54c&gt; : stop)
    #3-&gt;irb#3 on #&lt;Foo:0x4010af3c&gt; (#&lt;Thread:0x4010a1e0&gt; : running)
    nil
    irb#3(#&lt;Foo:0x4010af3c&gt;):002:0&gt; foo         # evaluate f.foo
    1nil
    irb#3(#&lt;Foo:0x4010af3c&gt;):003:0&gt; bar         # evaluate f.bar
    barnil
    irb#3(#&lt;Foo:0x4010af3c&gt;):004:0&gt; kill 1, 2, 3# kill job
    nil
    irb(main):009:0&gt; jobs
    #0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : running)
    nil
    irb(main):010:0&gt; exit                       # exit
    dim% 
</PRE>

<A NAME="lbAL">&nbsp;</A>
<H2>Restrictions</H2>

<P>

Because irb evaluates the inputs immediately after the imput is
syntactically completed, irb gives slight different result than
directly use ruby. Known difference is pointed out here. 
<A NAME="lbAM">&nbsp;</A>
<H2>Declaration of the local variable</H2>

<P>

The following causes an error in ruby:
<PRE>
    eval &quot;foo = 0&quot;
    foo
    --
    -:2: undefined local variable or method `foo' for #&lt;Object:0x40283118&gt; (NameError)
    ---
    NameError
</PRE>

Though, the above will successfully done by irb. 
<PRE>
    &gt;&gt; eval &quot;foo = 0&quot;
</PRE>

<PRE>
    =&gt; 0
    &gt;&gt; foo
    =&gt; 0
</PRE>

Ruby evaluates a code after reading entire of code and determination
of the scope of local variables. On the other hand, irb do
immediately. More precisely, irb evaluate at first
<PRE>
    evel &quot;foo = 0&quot; 
</PRE>

then foo is defined on this timing. It is because of this
incompatibility.
If you'd like to detect those differences, begin...end can be used:
<PRE>
    &gt;&gt; begin
    ?&gt;   eval &quot;foo = 0&quot;
    &gt;&gt;   foo
    &gt;&gt; end
    NameError: undefined local variable or method `foo' for #&lt;Object:0x4013d0f0&gt;
    (irb):3
    (irb_local_binding):1:in `eval'
</PRE>

<A NAME="lbAN">&nbsp;</A>
<H2>Here-document</H2>

<P>

Implementation of Here-document is incomplete. 
<A NAME="lbAO">&nbsp;</A>
<H2>Symbol</H2>

<P>

Irb can not always recognize a symbol as to be Symbol. Concretely, an
expression have completed, however Irb regard it as continuation line.
<P>
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">What is irb?</A><DD>
<DT><A HREF="#lbAC">Invoking</A><DD>
<DT><A HREF="#lbAD">Usage</A><DD>
<DT><A HREF="#lbAE">Command line option</A><DD>
<DT><A HREF="#lbAF">Configurations</A><DD>
<DT><A HREF="#lbAG">Customizing prompt</A><DD>
<DT><A HREF="#lbAH">Configurating subirb</A><DD>
<DT><A HREF="#lbAI">Command</A><DD>
<DT><A HREF="#lbAJ">System variable</A><DD>
<DT><A HREF="#lbAK">Session Example</A><DD>
<DT><A HREF="#lbAL">Restrictions</A><DD>
<DT><A HREF="#lbAM">Declaration of the local variable</A><DD>
<DT><A HREF="#lbAN">Here-document</A><DD>
<DT><A HREF="#lbAO">Symbol</A><DD>
</DL>

</div>






</div>




</body>
</html>
