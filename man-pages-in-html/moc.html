
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<title>moc</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="/global/main.css" title="default">
</head>

<body>



<div id="container">


<div id="content">

<div id='catHeader'><table width='100%'><tr><td>
<H1>moc</H1>
Section: User Commands  (1)<BR>Updated: 24 June 2001<BR>
</td><td align='right' valign='bottom'><div class='ad_header_right'></div></td></tr></table></div></div>
<div id='categories'>
<div class='ad_man_right'>
</div>










<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

moc - generate Qt meta object support code
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<B>moc</B>

[-o file] [-i] [-f] [-k] [-ldbg] [-nw] [-p path] [-q path] [-v] file
<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

This page documents the
<B>Meta Object Compiler</B>

for the Qt GUI application framework. The
<B>moc</B>

reads one or more C++ class declarations from a C++ header or source
file and generates one C++ source file containing meta object
information for the classes. The C++ source file generated by the
<B>moc</B>

must be compiled and linked with the implementation of the class (or it
can be #included into the class's source file).
<P>

If you use 
<B>qmake</B>

to create your Makefiles, build rules will be included that call the
<B>moc</B>

when required, so you will not need to use the 
<B>moc</B>

directly.
<P>

In brief, the meta object system is a structure used by Qt (see
<B><A HREF="http://doc.trolltech.com">http://doc.trolltech.com</A></B>)

for component programming and run time type information.  It adds
properties and inheritance information to (some) classes and
provides a new type of communication between those instances of those
classes, signal-slot
connections.
<A NAME="lbAE">&nbsp;</A>
<H2>OPTIONS</H2>

<DL COMPACT>
<DT><I>-o file</I>

<DD>
Write output to
<I>file</I>

rather than to stdout.
<DT><I>-f</I>

<DD>
Force the generation of an #include statement in the output.
This is the default for files whose name matches the regular
expression .[hH][^.]* (i.e. the extension starts with
<B>H</B>

or
<B>h</B>

). This
option is only useful if you have header files that do not follow the
standard naming conventions.
<DT><I>-i</I>

<DD>
Do not generate an #include statement in the output.  This may be used
to run
<B>moc</B>

on a C++ file containing one or more class declarations. You should then
#include the meta object code in the .cpp file (see USAGE below).  If both
<I>-f</I>

and
<I>-i</I>

are present, the last one wins.
<DT><I>-nw</I>

<DD>
Do not generate any warnings. Not recommended.
<DT><I>-ldbg</I>

<DD>
Write a flood of lex debug information to stdout.
<DT><I>-p path</I>

<DD>
Makes
<B>moc</B>

prepend
<I>path</I>/

to the file name in the generated #include statement (if one is generated).
<DT><I>-q path</I>

<DD>
Makes
<B>moc</B>

prepend
<I>path</I>/

to the file name of qt #include files in the generated code.
<DT><I>-v</I>

<DD>
Displays the version of
<B>moc</B>

and Qt.
</DL>
<P>

You can explicitly tell the
<B>moc</B>

not to parse parts of a header
file. It recognizes any C++ comment (//) that contains the substrings
MOC_SKIP_BEGIN or MOC_SKIP_END. They work as you would expect and you
can have several levels of them. The net result as seen by the
<B>moc</B>

is as if you had removed all lines between a MOC_SKIP_BEGIN and a
MOC_SKIP_END
<A NAME="lbAF">&nbsp;</A>
<H2>USAGE</H2>

<B>moc</B>

is almost always invoked by
<B><A HREF="../man1/make.1.php">make</A></B>(1),

not by hand.
<P>

<B>moc</B>

is typically used with an input file containing class declarations
like this:
<P>


<PRE>
class YourClass : public QObject {
    Q_OBJECT
    Q_PROPERTY( ... )
    Q_CLASSINFO( ... )

public:
    YourClass( QObject * parent=0, const char * name=0 );
    ~YourClass();

signals:

public slots:

};
</PRE>


<P>

Here is a useful makefile rule if you only use GNU make:
<P>


<PRE>
m%.cpp: %.h
        moc $&lt; -o $@
</PRE>


<P>

If you want to write portably, you can use individual rules of the
following form:
<P>


<PRE>
mNAME.cpp: NAME.h
        moc $&lt; -o $@
</PRE>


<P>

You must also remember to add
<I>mNAME.cpp</I>

to your SOURCES (substitute your favorite name) variable and
<I>mNAME.o</I>

to your OBJECTS variable.
<P>

(While we prefer to name our C++ source files .cpp, the
<B>moc</B>

doesn't know that, so you can use .C, .cc, .CC, .cxx or even .c++ if
you prefer.)
<P>

If you have class declarations in C++ files, we recommend that you use
a makefile rule like this:
<P>


<PRE>
NAME.o: mNAME.cpp

mNAME.cpp: NAME.cpp
        moc -i $&lt; -o $@
</PRE>


<P>

This guarantees that
<B><A HREF="../man1/make.1.php">make</A></B>(1)

will run the
<B>moc</B>

before it compiles
<I>NAME.cpp</I>.

You can then put
<P>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;
#include &quot;nNAME.cpp&quot;
<P>

at the end of
<I>NAME.cpp</I>,

where all the classes declared in that file are fully known.
<A NAME="lbAG">&nbsp;</A>
<H2>DIAGNOSTICS</H2>

Sometimes you may get linkage errors, saying that
YourClass::className() is undefined or that YourClass lacks a vtbl.
Those errors happen most often when you forget to compile the
moc-generated C++ code or include that object file in the link
command.
<P>

The
<B>moc</B>

will warn you about a number of dangerous or illegal constructs.
<A NAME="lbAH">&nbsp;</A>
<H2>BUGS</H2>

<P>
The
<B>moc</B>

does not expand #include or #define, it simply skips any preprocessor
directives it encounters. This is regrettable, but is normally not a
problem in practice.
<P>
The
<B>moc</B>

does not handle all of C++.  The main problem is that class templates
cannot have signals or slots.  This is an important bug.  Here is an
example:
<P>


<PRE>
class SomeTemplate&lt;int&gt; : public QFrame {
    Q_OBJECT
    ....
signals:
    void bugInMocDetected( int );
};
</PRE>


<P>

Less importantly, the following constructs are illegal.  All of them
have have alternatives which we think are usually better, so removing
these limitations is not a high priority for us.
<A NAME="lbAI">&nbsp;</A>
<H3>Multiple inheritance requires QObject to be first.</H3>

If you are using multiple inheritance, 
<B>moc </B>

assumes that the
<B>first</B>

inherited class is a subclass of QObject.  Also, be sure that
<B>only</B>

the first inherited class is a QObject.
<P>


<PRE>
class SomeClass : public QObject, public OtherClass {
    ...
};
</PRE>


<P>

This bug is almost impossible to fix; since the
<B>moc</B>

does not expand
#include or #define, it cannot find out which one of the base classes is a
QObject.
<A NAME="lbAJ">&nbsp;</A>
<H3>Function pointers cannot be arguments to signals or slots.</H3>

In most cases where you would consider that, we think inheritance is a
better alternative.  Here is an example of illegal syntax:
<P>


<PRE>
class SomeClass : public QObject {
    Q_OBJECT
    ...
public slots:
    // illegal
    void apply( void (*apply)(List *, void *), void * );
};
</PRE>


<P>

You can work around this restriction like this:
<P>


<PRE>
typedef void (*ApplyFunctionType)( List *, void * );

class SomeClass : public QObject {
    Q_OBJECT
    ...
public slots:
    void apply( ApplyFunctionType, char * );
};
</PRE>


<P>

It may sometimes be even better to replace the function pointer with
inheritance and virtual functions, signals or slots.
<A NAME="lbAK">&nbsp;</A>
<H3>Friend declarations cannot be placed in signals or slots sections</H3>

Sometimes it will work, but in general, friend declarations cannot be
placed in
<B>signals</B>

or
<B>slots</B>

sections.  Put them in the good old
<B>private</B>, <B>protected</B>

or
<B>public</B>

sections instead.  Here is an example of the illegal syntax:
<P>


<PRE>
class SomeClass : public QObject {
    Q_OBJECT
    ...
signals:
    friend class ClassTemplate&lt;char&gt;; // illegal
};
</PRE>


<A NAME="lbAL">&nbsp;</A>
<H3>Signals and slots cannot be upgraded</H3>

The C++ feature of upgrading an inherited member function to
<B>public</B>

status is not extended to cover signals and slots.  Here is an illegal
example:
<P>


<PRE>
class Whatever : public QButtonGroup {
    ...
public slots:
    QButtonGroup::buttonPressed; // illegal
    ...
};
</PRE>


<P>

The QButtonGroup::buttonPressed() slot is protected.
<P>

C++ quiz: What happens if you try to upgrade a protected member
function which is overloaded?
<DL COMPACT>
<DT><DD>
- All the functions are upgraded.
<DT><DD>
- That is not legal C++.

</DL>
<A NAME="lbAM">&nbsp;</A>
<H3>Type macros cannot be used for signal and slot arguments</H3>

<P>
Since the
<B>moc</B>

does not expand #define, type macros that take an argument
will not work in signals and slots. Here is an illegal example:
<P>


<PRE>
#ifdef ultrix
#define SIGNEDNESS(a) unsigned a
#else
#define SIGNEDNESS(a) a
#endif
class Whatever : public QObject {
    ...
signals:
    void someSignal( SIGNEDNESS(int) ); // illegal
};

A #define without arguments works.
</PRE>


<A NAME="lbAN">&nbsp;</A>
<H3>Nested classes cannot be in the signals or slots sections nor have signals or slots</H3>

Here's an example:
<P>


<PRE>
class A {
    Q_OBJECT
public:
    class B {
    public slots: // illegal
        void b();
        ...
    };
signals:
    class B {  // illegal
        void b();
        ...
    }:
};
</PRE>


<P>

<A NAME="lbAO">&nbsp;</A>
<H3>Constructors cannot be used in signals or slots sections</H3>

It is a mystery to us why anyone would put a constructor on either the
<B>signals</B>

or
<B>slots</B>

sections.  You can't, anyway (except that it happens to work in some
cases).  Put them in
<B>private</B>, <B>protected</B>

or
<B>public</B>

sections, where they belong.  Here is an example of the illegal syntax:
<P>


<PRE>
class SomeClass : public QObject {
    Q_OBJECT
public slots:
    SomeClass( QObject *parent, const char *name )
        : QObject( parent, name ) {} // illegal
    ...
};
</PRE>


<A NAME="lbAP">&nbsp;</A>
<H3>Properties need to be declared before the public section that contains the respective get and set functions</H3>

<P>

Declaring the first property within or after the public section that
contains the type definition and the respective get and set functions
does not work as expected. The
<B>moc</B>

will complain that it can neither
find the functions nor resolve the type. Here is an example of the
illegal syntax:
<P>


<PRE>
class SomeClass : public QObject {
    Q_OBJECT
public:
    ...
    // illegal
    Q_PROPERTY( Priority priority READ priority WRITE setPriority )
    Q_ENUMS( Priority )
    enum Priority { High, Low, VeryHigh, VeryLow };
    void setPriority( Priority );
    Priority priority() const;
    ...
};
</PRE>


<P>

Work around this limitation by declaring all properties at the
beginning of the class declaration, right after Q_OBJECT:
<P>


<PRE>
class SomeClass : public QObject {
    Q_OBJECT
    Q_PROPERTY( Priority priority READ priority WRITE setPriority )
    Q_ENUMS( Priority )
public:
    ...
    enum Priority { High, Low, VeryHigh, VeryLow };
    void setPriority( Priority );
    Priority priority() const;
    ...
};
</PRE>


<P>

<A NAME="lbAQ">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="http://www.trolltech.com">http://www.trolltech.com</A></B>, 

<B>C++ ARM, section r.11.3</B> (for the answer to the quiz), and

<B><A HREF="http://doc.trolltech.com">http://doc.trolltech.com</A></B> (for complete Qt documentation).

<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">OPTIONS</A><DD>
<DT><A HREF="#lbAF">USAGE</A><DD>
<DT><A HREF="#lbAG">DIAGNOSTICS</A><DD>
<DT><A HREF="#lbAH">BUGS</A><DD>
<DL>
<DT><A HREF="#lbAI">Multiple inheritance requires QObject to be first.</A><DD>
<DT><A HREF="#lbAJ">Function pointers cannot be arguments to signals or slots.</A><DD>
<DT><A HREF="#lbAK">Friend declarations cannot be placed in signals or slots sections</A><DD>
<DT><A HREF="#lbAL">Signals and slots cannot be upgraded</A><DD>
<DT><A HREF="#lbAM">Type macros cannot be used for signal and slot arguments</A><DD>
<DT><A HREF="#lbAN">Nested classes cannot be in the signals or slots sections nor have signals or slots</A><DD>
<DT><A HREF="#lbAO">Constructors cannot be used in signals or slots sections</A><DD>
<DT><A HREF="#lbAP">Properties need to be declared before the public section that contains the respective get and set functions</A><DD>
</DL>
<DT><A HREF="#lbAQ">SEE ALSO</A><DD>
</DL>

</div>






</div>




</body>
</html>
